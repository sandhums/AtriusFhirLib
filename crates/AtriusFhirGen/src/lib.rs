//! # Bootstrap FHIR Model Types
//!
//! This module contains the minimal set of hand-coded Rust types necessary to parse
//! FHIR StructureDefinitions from JSON specification files. These types bootstrap
//! the code generation process by providing just enough structure to read and
//! understand the FHIR specification files themselves.
//!
//! ## Purpose
//!
//! The types in this module serve a specific, limited purpose:
//! - Parse FHIR Bundle files containing StructureDefinitions
//! - Extract type information and element definitions
//! - Enable the code generator to understand FHIR type relationships
//!
//! ## Design Principles
//!
//! 1. **Minimal Scope**: Only includes types needed to parse StructureDefinitions
//! 2. **Bootstrap Only**: These are not the "real" FHIR types (those are generated)
//! 3. **JSON Compatible**: Designed specifically for deserializing specification files
//! 4. **No Business Logic**: Pure data structures for code generation input
//!
//! ## Key Types
//!
//! - [`Bundle`] - Container for FHIR specification entries
//! - [`StructureDefinition`] - Core FHIR type definition format
//! - [`ElementDefinition`] - Individual element specifications within structures
//! - [`Extension`] - FHIR extension mechanism with choice types
//! - Basic data types like [`Address`], [`Coding`], [`CodeableConcept`]
//!
//! ## Relationship to Generated Code
//!
//! The full, feature-complete FHIR types are generated by the code generator and
//! placed in the main `fhir` crate. This module's types are only used during the
//! generation process itself.

use std::io::{self, Write};
use std::path::{Path, PathBuf};
use atrius_fhir_lib::fhir_version::FhirVersion;
use crate::gen_helpers::{detect_struct_cycles, extract_bundle_info, generate_global_constructs, is_valid_structure_definition, parse_structure_definitions, structure_definition_to_rust, visit_dirs};
use crate::generate_version_header::generate_version_header;
use crate::meta_datatypes::Resource;

pub(crate) mod base_types;
mod complex_datatypes;
mod meta_datatypes;
mod element_definition;
mod structure_definition;
mod capability_statement;
mod bundle;
mod others;
mod generate_version_header;
mod gen_helpers;
mod generate_resource_enum;
mod format_helpers;
mod generate_struct_element_doc;
mod gen_element_definitions;

/// Processes one or more FHIR versions and generates corresponding Rust code.
///
/// This is the main entry point for the code generation process. It can either
/// process a specific FHIR version or all available versions based on enabled features.
///
/// # Arguments
///
/// * `version` - Optional specific FHIR version to process. If `None`, processes all
///   versions that are enabled via Cargo features
/// * `output_path` - Directory where generated Rust files will be written
///
/// # Returns
///
/// Returns `Ok(())` on success. If processing multiple versions, continues even if
/// individual versions fail (with warnings), returning `Ok(())` as long as the
/// overall process completes.
///
/// # Feature Dependencies
///
/// The versions processed depend on which Cargo features are enabled:
/// - `R4` - FHIR Release 4 (default)
/// - `R4B` - FHIR Release 4B
/// - `R5` - FHIR Release 5
/// - `R6` - FHIR Release 6
///
/// # Examples
///
/// ```ignore
/// use helios_fhir_gen::process_fhir_version;
/// use helios_fhir::FhirVersion;
/// use std::path::PathBuf;
///
/// let output_dir = PathBuf::from("crates/fhir/src");
///
/// // Process only R4
/// process_fhir_version(Some(FhirVersion::R4), &output_dir)?;
///
/// // Process all enabled versions
/// process_fhir_version(None, &output_dir)?;
/// # Ok::<(), std::io::Error>(())
/// ```
pub fn process_fhir_version(
    version: Option<FhirVersion>,
    output_path: impl AsRef<Path>,
) -> io::Result<()> {
    match version {
        None => {
            // Process all versions
            for ver in [
                #[cfg(feature = "R4")]
                FhirVersion::R4,
                #[cfg(feature = "R4B")]
                FhirVersion::R4B,
                #[cfg(feature = "R5")]
                FhirVersion::R5,
                #[cfg(feature = "R6")]
                FhirVersion::R6,
            ] {
                if let Err(e) = process_single_version(&ver, &output_path) {
                    eprintln!("Warning: Failed to process {:?}: {}", ver, e);
                }
            }
            Ok(())
        }
        Some(specific_version) => process_single_version(&specific_version, output_path),
    }
}

/// Processes a single FHIR version and generates corresponding Rust code.
///
/// This function loads all JSON specification files for the given FHIR version,
/// parses the StructureDefinitions, and generates Rust code for all valid types.
///
/// # Arguments
///
/// * `version` - The FHIR version to process (R4, R4B, R5, or R6)
/// * `output_path` - Directory where the generated Rust files will be written
///
/// # Returns
///
/// Returns `Ok(())` on success, or an `io::Error` if file operations fail.
///
/// # Generated Output
///
/// Creates a single `.rs` file named after the version (e.g., `r4.rs`) containing:
/// - Type definitions for all FHIR resources and data types
/// - Choice type enums for polymorphic elements
/// - A unified Resource enum for all resource types
/// - Proper serialization/deserialization attributes
///
/// # Example
///
/// ```ignore
/// use helios_fhir_gen::process_single_version;
/// use helios_fhir::FhirVersion;
/// use std::path::PathBuf;
///
/// let output_dir = PathBuf::from("generated");
/// process_single_version(&FhirVersion::R4, &output_dir)?;
/// # Ok::<(), std::io::Error>(())
/// ```
fn process_single_version(version: &FhirVersion, output_path: impl AsRef<Path>) -> io::Result<()> {
    let resources_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("resources");
    let version_dir = resources_dir.join(version.as_str());
    // Create output directory if it doesn't exist
    std::fs::create_dir_all(output_path.as_ref())?;

    let version_path = output_path
        .as_ref()
        .join(format!("{}.rs", version.as_str().to_lowercase()));

    // Create the version-specific output file with comprehensive header
    std::fs::write(&version_path, generate_version_header(version))?;

    // Collect all type hierarchy information across all bundles
    let mut global_type_hierarchy = std::collections::HashMap::new();
    let mut all_resources = Vec::new();
    let mut all_complex_types = Vec::new();

    // First pass: parse all JSON files and collect all StructureDefinitions
    let bundles: Vec<_> = visit_dirs(&version_dir)?
        .into_iter()
        .filter_map(|file_path| match parse_structure_definitions(&file_path) {
            Ok(bundle) => Some(bundle),
            Err(e) => {
                eprintln!("Warning: Failed to parse {}: {}", file_path.display(), e);
                None
            }
        })
        .collect();

    // Collect and extract all elements for cycle detection
    let mut all_elements = Vec::new();
    let mut all_struct_defs = Vec::new();

    for bundle in &bundles {
        if let Some(entries) = bundle.entry.as_ref() {
            for entry in entries {
                if let Some(resource) = &entry.resource {
                    if let Resource::StructureDefinition(def) = resource {
                        if is_valid_structure_definition(def) {
                            all_struct_defs.push(def);
                            if let Some(snapshot) = &def.snapshot {
                                if let Some(elements) = &snapshot.element {
                                    all_elements.extend(elements.iter());
                                }
                            }
                        }
                    }
                }
            }
        }

        // Extract global information
        if let Some((hierarchy, resources, complex_types)) = extract_bundle_info(bundle) {
            global_type_hierarchy.extend(hierarchy);
            all_resources.extend(resources);
            all_complex_types.extend(complex_types);
        }
    }

    // Sort StructureDefinitions by name for deterministic output
    all_struct_defs.sort_by(|a, b| a.name.cmp(&b.name));

    // Detect cycles across all elements
    let cycles = detect_struct_cycles(&all_elements);

    // Generate code for each StructureDefinition in sorted order
    for def in all_struct_defs {
        let content = structure_definition_to_rust(def, &cycles);
        let mut file = std::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open(&version_path)?;
        write!(file, "{}", content)?;
    }

    // Sort for deterministic output
    all_resources.sort();
    all_resources.dedup();
    all_complex_types.sort();
    all_complex_types.dedup();

    // Generate global constructs once at the end
    generate_global_constructs(
        &version_path,
        &global_type_hierarchy,
        &all_resources,
        &all_complex_types,
    )?;

    Ok(())
}



