//! # Bootstrap FHIR Model Types
//!
//! This module contains the minimal set of hand-coded Rust types necessary to parse
//! FHIR StructureDefinitions from JSON specification files. These types bootstrap
//! the code generation process by providing just enough structure to read and
//! understand the FHIR specification files themselves.
//!
//! ## Purpose
//!
//! The types in this module serve a specific, limited purpose:
//! - Parse FHIR Bundle files containing StructureDefinitions
//! - Extract type information and element definitions
//! - Enable the code generator to understand FHIR type relationships
//!
//! ## Design Principles
//!
//! 1. **Minimal Scope**: Only includes types needed to parse StructureDefinitions
//! 2. **Bootstrap Only**: These are not the "real" FHIR types (those are generated)
//! 3. **JSON Compatible**: Designed specifically for deserializing specification files
//! 4. **No Business Logic**: Pure data structures for code generation input
//!
//! ## Key Types
//!
//! - [`Bundle`] - Container for FHIR specification entries
//! - [`StructureDefinition`] - Core FHIR type definition format
//! - [`ElementDefinition`] - Individual element specifications within structures
//! - [`Extension`] - FHIR extension mechanism with choice types
//! - Basic data types like [`Address`], [`Coding`], [`CodeableConcept`]
//!
//! ## Relationship to Generated Code
//!
//! The full, feature-complete FHIR types are generated by the code generator and
//! placed in the main `fhir` crate. This module's types are only used during the
//! generation process itself.

use std::collections::{HashMap, HashSet};
use std::io::{self, Write};
use std::path::{Path, PathBuf};
use atrius_fhir_lib::fhir_version::FhirVersion;
use crate::directory_output_helpers::{module_file_stem, write_mod_index};
use crate::gen_helpers::{detect_struct_cycles, extract_bundle_info, generate_global_constructs, is_valid_structure_definition, parse_structure_definitions, structure_definition_to_rust, visit_dirs};
use crate::generate_version_header::generate_version_header;
use crate::meta_datatypes::Resource;

pub(crate) mod base_types;
mod complex_datatypes;
mod meta_datatypes;
mod element_definition;
mod structure_definition;
mod capability_statement;
mod bundle;
mod others;
mod generate_version_header;
mod gen_helpers;
mod generate_resource_enum;
mod format_helpers;
mod generate_struct_element_doc;
mod gen_element_definitions;
mod constraint_helpers;
mod directory_output_helpers;

/// Processes one or more FHIR versions and generates corresponding Rust code.
///
/// This is the main entry point for the code generation process. It can either
/// process a specific FHIR version or all available versions based on enabled features.
///
/// # Arguments
///
/// * `version` - Optional specific FHIR version to process. If `None`, processes all
///   versions that are enabled via Cargo features
/// * `output_path` - Directory where generated Rust files will be written
///
/// # Returns
///
/// Returns `Ok(())` on success. If processing multiple versions, continues even if
/// individual versions fail (with warnings), returning `Ok(())` as long as the
/// overall process completes.
///
/// # Feature Dependencies
///
/// The versions processed depend on which Cargo features are enabled:
/// - `R4` - FHIR Release 4 (default)
/// - `R4B` - FHIR Release 4B
/// - `R5` - FHIR Release 5
/// - `R6` - FHIR Release 6
///
/// # Examples
///
/// ```ignore
/// use helios_fhir_gen::process_fhir_version;
/// use helios_fhir::FhirVersion;
/// use std::path::PathBuf;
///
/// let output_dir = PathBuf::from("crates/fhir/src");
///
/// // Process only R4
/// process_fhir_version(Some(FhirVersion::R4), &output_dir)?;
///
/// // Process all enabled versions
/// process_fhir_version(None, &output_dir)?;
/// # Ok::<(), std::io::Error>(())
/// ```
pub fn process_fhir_version(
    version: Option<FhirVersion>,
    output_path: impl AsRef<Path>,
) -> io::Result<()> {
    match version {
        None => {
            // Process all versions
            for ver in [
                #[cfg(feature = "R4")]
                FhirVersion::R4,
                #[cfg(feature = "R4B")]
                FhirVersion::R4B,
                #[cfg(feature = "R5")]
                FhirVersion::R5,
                #[cfg(feature = "R6")]
                FhirVersion::R6,
            ] {
                if let Err(e) = process_single_version_dir(&ver, &output_path) {
                    eprintln!("Warning: Failed to process {:?}: {}", ver, e);
                }
            }
            Ok(())
        }
        Some(specific_version) => process_single_version_dir(&specific_version, output_path),
    }
}

/// Processes a single FHIR version and generates corresponding Rust code.
///
/// This function loads all JSON specification files for the given FHIR version,
/// parses the StructureDefinitions, and generates Rust code for all valid types.
///
/// # Arguments
///
/// * `version` - The FHIR version to process (R4, R4B, R5, or R6)
/// * `output_path` - Directory where the generated Rust files will be written
///
/// # Returns
///
/// Returns `Ok(())` on success, or an `io::Error` if file operations fail.
///
/// # Generated Output
///
/// Creates a single `.rs` file named after the version (e.g., `r4.rs`) containing:
/// - Type definitions for all FHIR resources and data types
/// - Choice type enums for polymorphic elements
/// - A unified Resource enum for all resource types
/// - Proper serialization/deserialization attributes
///
/// # Example
///
/// ```ignore
/// use helios_fhir_gen::process_single_version;
/// use helios_fhir::FhirVersion;
/// use std::path::PathBuf;
///
/// let output_dir = PathBuf::from("generated");
/// process_single_version(&FhirVersion::R4, &output_dir)?;
/// # Ok::<(), std::io::Error>(())
/// ```
fn process_single_version(version: &FhirVersion, output_path: impl AsRef<Path>) -> io::Result<()> {
    let resources_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("resources");
    let version_dir = resources_dir.join(version.as_str());
    // Create output directory if it doesn't exist
    std::fs::create_dir_all(output_path.as_ref())?;

    let version_path = output_path
        .as_ref()
        .join(format!("{}.rs", version.as_str().to_lowercase()));

    // Create the version-specific output file with comprehensive header
    std::fs::write(&version_path, generate_version_header(version))?;

    // Collect all type hierarchy information across all bundles
    let mut global_type_hierarchy = std::collections::HashMap::new();
    let mut all_resources = Vec::new();
    let mut all_complex_types = Vec::new();

    // First pass: parse all JSON files and collect all StructureDefinitions
    let bundles: Vec<_> = visit_dirs(&version_dir)?
        .into_iter()
        .filter_map(|file_path| match parse_structure_definitions(&file_path) {
            Ok(bundle) => Some(bundle),
            Err(e) => {
                eprintln!("Warning: Failed to parse {}: {}", file_path.display(), e);
                None
            }
        })
        .collect();

    // Collect and extract all elements for cycle detection
    let mut all_elements = Vec::new();
    let mut all_struct_defs = Vec::new();

    for bundle in &bundles {
        if let Some(entries) = bundle.entry.as_ref() {
            for entry in entries {
                if let Some(resource) = &entry.resource {
                    if let Resource::StructureDefinition(def) = resource {
                        if is_valid_structure_definition(def) {
                            all_struct_defs.push(def);
                            if let Some(snapshot) = &def.snapshot {
                                if let Some(elements) = &snapshot.element {
                                    all_elements.extend(elements.iter());
                                }
                            }
                        }
                    }
                }
            }
        }

        // Extract global information
        if let Some((hierarchy, resources, complex_types)) = extract_bundle_info(bundle) {
            global_type_hierarchy.extend(hierarchy);
            all_resources.extend(resources);
            all_complex_types.extend(complex_types);
        }
    }

    // Sort StructureDefinitions by name for deterministic output
    all_struct_defs.sort_by(|a, b| a.name.cmp(&b.name));

    // Detect cycles across all elements
    let cycles = detect_struct_cycles(&all_elements);

    // Generate code for each StructureDefinition in sorted order
    for def in all_struct_defs {
        let content = structure_definition_to_rust(def, &cycles);
        let mut file = std::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open(&version_path)?;
        write!(file, "{}", content)?;
    }

    // Sort for deterministic output
    all_resources.sort();
    all_resources.dedup();
    all_complex_types.sort();
    all_complex_types.dedup();

    // Generate global constructs once at the end
    generate_global_constructs(
        &version_path,
        &global_type_hierarchy,
        &all_resources,
        &all_complex_types,
    )?;

    Ok(())
}

/// Creates a directory structure under `<output>/<version>/` containing:
/// - A `mod.rs` root module file
/// - Subdirectories for `primitives/`, `complex_types/`, and `resources/`
/// - Each type in its own file within the appropriate subdirectory
/// - Index `mod.rs` files in each subdirectory for module re-exports

fn process_single_version_dir(version: &FhirVersion, output_path: impl AsRef<Path>) -> io::Result<()> {
    let resources_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("resources");
    let version_dir = resources_dir.join(version.as_str());

    // Create output directory structure:
    //   <output>/<version>/
    //     mod.rs
    //     primitives/
    //     complex_types/
    //     resources/
    std::fs::create_dir_all(output_path.as_ref())?;

    let version_mod_name = version.as_str().to_lowercase();
    let version_out_dir = output_path.as_ref().join(&version_mod_name);
    let primitives_dir = version_out_dir.join("primitives");
    let complex_dir = version_out_dir.join("complex_types");
    let resources_out_dir = version_out_dir.join("resources");

    std::fs::create_dir_all(&primitives_dir)?;
    std::fs::create_dir_all(&complex_dir)?;
    std::fs::create_dir_all(&resources_out_dir)?;

    // Root module file (acts like the old single huge <version>.rs)
    let version_mod_rs = version_out_dir.join("mod.rs");

    // Write header into the root module file
    std::fs::write(&version_mod_rs, generate_version_header(version))?;

    // Add submodule declarations; their own mod.rs will be generated later.
    {
        let mut file = std::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open(&version_mod_rs)?;
        writeln!(file, "pub mod primitives;")?;
        writeln!(file, "pub mod complex_types;")?;
        writeln!(file, "pub mod resources;")?;
        writeln!(file)?;
        writeln!(file, "pub use primitives::*;")?;
        writeln!(file, "pub use complex_types::*;")?;
        writeln!(file, "pub use resources::*;")?;
        writeln!(file)?;
    }


    // Collect all type hierarchy information across all bundles
    let mut global_type_hierarchy: HashMap<String, String> = HashMap::new();
    let mut all_resources: Vec<String> = Vec::new();
    let mut all_complex_types: Vec<String> = Vec::new();

    // First pass: parse all JSON files and collect all StructureDefinitions
    let bundles: Vec<_> = visit_dirs(&version_dir)?
        .into_iter()
        .filter_map(|file_path| match parse_structure_definitions(&file_path) {
            Ok(bundle) => Some(bundle),
            Err(e) => {
                eprintln!("Warning: Failed to parse {}: {}", file_path.display(), e);
                None
            }
        })
        .collect();

    // Collect and extract all elements for cycle detection
    let mut all_elements = Vec::new();
    let mut all_struct_defs = Vec::new();

    for bundle in &bundles {
        if let Some(entries) = bundle.entry.as_ref() {
            for entry in entries {
                if let Some(resource) = &entry.resource {
                    if let Resource::StructureDefinition(def) = resource {
                        if is_valid_structure_definition(def) {
                            all_struct_defs.push(def);
                            if let Some(snapshot) = &def.snapshot {
                                if let Some(elements) = &snapshot.element {
                                    all_elements.extend(elements.iter());
                                }
                            }
                        }
                    }
                }
            }
        }

        // Extract global information
        if let Some((hierarchy, resources, complex_types)) = extract_bundle_info(bundle) {
            global_type_hierarchy.extend(hierarchy);
            all_resources.extend(resources);
            all_complex_types.extend(complex_types);
        }
    }

    // Sort StructureDefinitions by name for deterministic output
    all_struct_defs.sort_by(|a, b| a.name.cmp(&b.name));

    // Detect cycles across all elements
    let cycles = detect_struct_cycles(&all_elements);

    // Prepare fast lookups for classification
    all_resources.sort();
    all_resources.dedup();
    all_complex_types.sort();
    all_complex_types.dedup();

    let resources_set: HashSet<&str> = all_resources.iter().map(|s| s.as_str()).collect();
    let complex_set: HashSet<&str> = all_complex_types.iter().map(|s| s.as_str()).collect();

    // Keep track of which modules we generated under each directory to emit mod.rs indexes
    let mut primitive_modules: Vec<String> = Vec::new();
    let mut complex_modules: Vec<String> = Vec::new();
    let mut resource_modules: Vec<String> = Vec::new();

    // Generate code for each StructureDefinition into its own file
    for def in all_struct_defs {
        let type_name = def.name.as_str();

        // Heuristic classification:
        // - If it appears in extracted resources list => resource
        // - Else if it appears in extracted complex types list => complex
        // - Else => primitive (covers primitive-type and any leftover special cases)
        let (target_dir, module_list) = if resources_set.contains(type_name) {
            (&resources_out_dir, &mut resource_modules)
        } else if complex_set.contains(type_name) {
            (&complex_dir, &mut complex_modules)
        } else {
            (&primitives_dir, &mut primitive_modules)
        };

        let mod_stem = module_file_stem(type_name);
        let out_file_path = target_dir.join(format!("{mod_stem}.rs"));

        // Generate the Rust code body
        let content = structure_definition_to_rust(def, &cycles);

        // Prelude so each file can resolve references similarly to the monolithic module.
        // This relies on `rX/mod.rs` re-exporting primitives/complex/resources.
        let mut file = std::fs::File::create(&out_file_path)?;
        writeln!(file, "// AUTO-GENERATED by atrius-fhir-generator ({} {})", version.as_str(), type_name)?;
        writeln!(file, "use crate::{}::*;", version_mod_name)?;
        writeln!(file)?;
        write!(file, "{}", content)?;

        module_list.push(mod_stem);
    }

    // Write directory index mod.rs files
    write_mod_index(&primitives_dir.join("mod.rs"), &primitive_modules)?;
    write_mod_index(&complex_dir.join("mod.rs"), &complex_modules)?;
    write_mod_index(&resources_out_dir.join("mod.rs"), &resource_modules)?;

    // Generate global constructs once at the end (Resource enums, providers, etc.)
    // Target the version root mod.rs so the public surface stays stable.
    generate_global_constructs(
        &version_mod_rs,
        &global_type_hierarchy,
        &all_resources,
        &all_complex_types,
    )?;

    Ok(())
}



