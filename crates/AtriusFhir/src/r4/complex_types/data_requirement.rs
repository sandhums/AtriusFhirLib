// AUTO-GENERATED by atrius-fhir-generator (R4 DataRequirement)
use crate::r4::*;

/// Choice of types for the subject\[x\] field in DataRequirement
#[derive(Debug, Clone, PartialEq, FhirSerde, FhirPath)]
#[fhir_choice_element(base_name = "subject")]
pub enum DataRequirementSubject {
    /// Variant accepting the CodeableConcept type.
    #[fhir_serde(rename = "subjectCodeableConcept")]
    CodeableConcept(CodeableConcept),
    /// Variant accepting the Reference type.
    #[fhir_serde(rename = "subjectReference")]
    Reference(Reference),
}

/// FHIR DataRequirement type
/// 
/// Base StructureDefinition for DataRequirement Type: Describes a required data
/// item for evaluation in terms of the type of data, and optional code or
/// date-based filters of the data.
/// 
/// ## Type: Complex-type type
/// Base type: http://hl7.org/fhir/StructureDefinition/Element
/// 
/// ## Status: draft
/// FHIR Version: 4.0.1
/// 
/// See: [DataRequirement](http://hl7.org/fhir/StructureDefinition/DataRequirement)
#[derive(Debug, Clone, PartialEq, FhirSerde, FhirPath, Default, FhirValidate)]
#[fhir_resource(choice_elements = "subject")]
#[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement")]
pub struct DataRequirement {
    /// Unique id for inter-element referencing
    /// 
    /// Unique id for the element within a resource (for internal references). This
    /// may be any string value that does not contain spaces.
    /// 
    /// ## Cardinality: Optional (0..1)
    pub id: Option<String>,
    /// Additional content defined by implementations
    /// 
    /// May be used to represent additional information that is not part of the basic
    /// definition of the element. To make the use of extensions safe and manageable,
    /// there is a strict set of governance applied to the definition and use of
    /// extensions. Though any implementer can define an extension, there is a set of
    /// requirements that SHALL be met as part of the definition of the extension.
    /// 
    /// ## Implementation Notes
    /// There can be no stigma associated with the use of extensions by any
    /// application, project, or standard - regardless of the institution or
    /// jurisdiction that uses or defines the extensions. The use of extensions is
    /// what allows the FHIR specification to retain a core level of simplicity for
    /// everyone.
    /// 
    /// ## Cardinality: Optional, Multiple (0..*)
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    /// - **ext-1**: Must have either extensions or value[x], not both (error)
    ///   Expression: `extension.exists() != value.exists()`
    /// 
    /// ## Aliases
    /// extensions, user content
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement.extension")]
    #[fhir_invariant(key="ext-1", severity="error", human="Must have either extensions or value[x], not both", expr="extension.exists() != value.exists()", path="DataRequirement.extension")]
    pub extension: Option<Vec<Extension>>,
    /// The type of the required data
    /// 
    /// The type of the required data, specified as the type name of a resource. For
    /// profiles, this value is set to the type of the base resource of the profile.
    /// 
    /// ## Cardinality: Required (1..1)
    /// 
    /// ## Special Semantics
    /// - Included in summary
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    /// 
    /// ## Binding
    /// - **Strength**: required
    /// - **Description**: A list of all the concrete types defined in this version of the FHIR specification - Abstract Types, Data Types and Resource Types.
    /// - **ValueSet**: http://hl7.org/fhir/ValueSet/all-types|4.0.1
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement.type")]
    #[fhir_serde(rename = "type")]
    pub r#type: Code,
    /// The profile of the required data
    /// 
    /// The profile of the required data, specified as the uri of the profile
    /// definition.
    /// 
    /// ## Cardinality: Optional, Multiple (0..*)
    /// 
    /// ## Special Semantics
    /// - Included in summary
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement.profile")]
    pub profile: Option<Vec<Canonical>>,
    /// E.g. Patient, Practitioner, RelatedPerson, Organization, Location, Device
    /// 
    /// The intended subjects of the data requirement. If this element is not
    /// provided, a Patient subject is assumed.
    /// 
    /// ## Implementation Notes
    /// The subject of a data requirement is critical, as the data being specified is
    /// determined with respect to a particular subject. This corresponds roughly to
    /// the notion of a Compartment in that it limits what data is available based on
    /// its relationship to the subject. In CQL, this corresponds to the context
    /// declaration.
    /// 
    /// ## Cardinality: Optional (0..1)
    /// 
    /// ## Special Semantics
    /// - Included in summary
    /// - When missing: Patient
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    /// 
    /// ## Binding
    /// - **Strength**: extensible
    /// - **Description**: The possible types of subjects for a data requirement (E.g., Patient, Practitioner, Organization, Location, etc.).
    /// - **ValueSet**: http://hl7.org/fhir/ValueSet/subject-type
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement.subject[x]")]
    #[fhir_serde(flatten)]
    pub subject: Option<DataRequirementSubject>,
    /// Indicates specific structure elements that are referenced by the knowledge module
    /// 
    /// Indicates that specific elements of the type are referenced by the knowledge
    /// module and must be supported by the consumer in order to obtain an effective
    /// evaluation. This does not mean that a value is required for this element,
    /// only that the consuming system must understand the element and be able to
    /// provide values for it if they are available.
    /// 
    /// The value of mustSupport SHALL be a FHIRPath resolveable on the type of the
    /// DataRequirement. The path SHALL consist only of identifiers, constant
    /// indexers, and .resolve() (see the [Simple FHIRPath
    /// Profile](fhirpath.html#simple) for full details).
    /// 
    /// ## Cardinality: Optional, Multiple (0..*)
    /// 
    /// ## Special Semantics
    /// - Included in summary
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement.mustSupport")]
    #[fhir_serde(rename = "mustSupport")]
    pub must_support: Option<Vec<String>>,
    /// What codes are expected
    /// 
    /// Code filters specify additional constraints on the data, specifying the value
    /// set of interest for a particular element of the data. Each code filter
    /// defines an additional constraint on the data, i.e. code filters are AND'ed,
    /// not OR'ed.
    /// 
    /// ## Cardinality: Optional, Multiple (0..*)
    /// 
    /// ## Special Semantics
    /// - Included in summary
    /// 
    /// ## Constraints
    /// - **drq-1**: Either a path or a searchParam must be provided, but not both (error)
    ///   Expression: `path.exists() xor searchParam.exists()`
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    #[fhir_invariant(key="drq-1", severity="error", human="Either a path or a searchParam must be provided, but not both", expr="path.exists() xor searchParam.exists()", path="DataRequirement.codeFilter")]
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement.codeFilter")]
    #[fhir_serde(rename = "codeFilter")]
    pub code_filter: Option<Vec<DataRequirementCodeFilter>>,
    /// What dates/date ranges are expected
    /// 
    /// Date filters specify additional constraints on the data in terms of the
    /// applicable date range for specific elements. Each date filter specifies an
    /// additional constraint on the data, i.e. date filters are AND'ed, not OR'ed.
    /// 
    /// ## Cardinality: Optional, Multiple (0..*)
    /// 
    /// ## Special Semantics
    /// - Included in summary
    /// 
    /// ## Constraints
    /// - **drq-2**: Either a path or a searchParam must be provided, but not both (error)
    ///   Expression: `path.exists() xor searchParam.exists()`
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    #[fhir_invariant(key="drq-2", severity="error", human="Either a path or a searchParam must be provided, but not both", expr="path.exists() xor searchParam.exists()", path="DataRequirement.dateFilter")]
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement.dateFilter")]
    #[fhir_serde(rename = "dateFilter")]
    pub date_filter: Option<Vec<DataRequirementDateFilter>>,
    /// Number of results
    /// 
    /// Specifies a maximum number of results that are required (uses the _count
    /// search parameter).
    /// 
    /// ## Requirements
    /// Enables the requirement "most recent 5 results" to be expressed.
    /// 
    /// ## Implementation Notes
    /// This element can be used in combination with the sort element to specify
    /// quota requirements such as "the most recent 5" or "the highest 5".
    /// 
    /// ## Cardinality: Optional (0..1)
    /// 
    /// ## Special Semantics
    /// - Included in summary
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement.limit")]
    pub limit: Option<PositiveInt>,
    /// Order of the results
    /// 
    /// Specifies the order of the results to be returned.
    /// 
    /// ## Requirements
    /// Enables the requirement "most recent 5 results" to be expressed.
    /// 
    /// ## Implementation Notes
    /// This element can be used in combination with the sort element to specify
    /// quota requirements such as "the most recent 5" or "the highest 5". When
    /// multiple sorts are specified, they are applied in the order they appear in
    /// the resource.
    /// 
    /// ## Cardinality: Optional, Multiple (0..*)
    /// 
    /// ## Special Semantics
    /// - Included in summary
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement.sort")]
    pub sort: Option<Vec<DataRequirementSort>>,
}

/// What codes are expected
/// 
/// Code filters specify additional constraints on the data, specifying the value
/// set of interest for a particular element of the data. Each code filter
/// defines an additional constraint on the data, i.e. code filters are AND'ed,
/// not OR'ed.
/// 
/// ## Cardinality: Optional, Multiple (0..*)
/// 
/// ## Special Semantics
/// - Included in summary
/// 
/// ## Constraints
/// - **drq-1**: Either a path or a searchParam must be provided, but not both (error)
///   Expression: `path.exists() xor searchParam.exists()`
/// - **ele-1**: All FHIR elements must have a @value or children (error)
///   Expression: `hasValue() or (children().count() > id.count())`
#[derive(Debug, Clone, PartialEq, FhirSerde, FhirPath, Default, FhirValidate)]
#[fhir_invariant(key="drq-1", severity="error", human="Either a path or a searchParam must be provided, but not both", expr="path.exists() xor searchParam.exists()", path="DataRequirement.codeFilter")]
#[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement.codeFilter")]
pub struct DataRequirementCodeFilter {
    /// Unique id for inter-element referencing
    /// 
    /// Unique id for the element within a resource (for internal references). This
    /// may be any string value that does not contain spaces.
    /// 
    /// ## Cardinality: Optional (0..1)
    pub id: Option<String>,
    /// Additional content defined by implementations
    /// 
    /// May be used to represent additional information that is not part of the basic
    /// definition of the element. To make the use of extensions safe and manageable,
    /// there is a strict set of governance applied to the definition and use of
    /// extensions. Though any implementer can define an extension, there is a set of
    /// requirements that SHALL be met as part of the definition of the extension.
    /// 
    /// ## Implementation Notes
    /// There can be no stigma associated with the use of extensions by any
    /// application, project, or standard - regardless of the institution or
    /// jurisdiction that uses or defines the extensions. The use of extensions is
    /// what allows the FHIR specification to retain a core level of simplicity for
    /// everyone.
    /// 
    /// ## Cardinality: Optional, Multiple (0..*)
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    /// - **ext-1**: Must have either extensions or value[x], not both (error)
    ///   Expression: `extension.exists() != value.exists()`
    /// 
    /// ## Aliases
    /// extensions, user content
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement.codeFilter.extension")]
    #[fhir_invariant(key="ext-1", severity="error", human="Must have either extensions or value[x], not both", expr="extension.exists() != value.exists()", path="DataRequirement.codeFilter.extension")]
    pub extension: Option<Vec<Extension>>,
    /// A code-valued attribute to filter on
    /// 
    /// The code-valued attribute of the filter. The specified path SHALL be a
    /// FHIRPath resolveable on the specified type of the DataRequirement, and SHALL
    /// consist only of identifiers, constant indexers, and .resolve(). The path is
    /// allowed to contain qualifiers (.) to traverse sub-elements, as well as
    /// indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple
    /// FHIRPath Profile](fhirpath.html#simple) for full details). Note that the
    /// index must be an integer constant. The path must resolve to an element of
    /// type code, Coding, or CodeableConcept.
    /// 
    /// ## Implementation Notes
    /// The path attribute contains a [Simple FHIRPath Subset](fhirpath.html#simple)
    /// that allows path traversal, but not calculation.
    /// 
    /// ## Cardinality: Optional (0..1)
    /// 
    /// ## Special Semantics
    /// - Included in summary
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement.codeFilter.path")]
    pub path: Option<String>,
    /// A coded (token) parameter to search on
    /// 
    /// A token parameter that refers to a search parameter defined on the specified
    /// type of the DataRequirement, and which searches on elements of type code,
    /// Coding, or CodeableConcept.
    /// 
    /// ## Cardinality: Optional (0..1)
    /// 
    /// ## Special Semantics
    /// - Included in summary
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement.codeFilter.searchParam")]
    #[fhir_serde(rename = "searchParam")]
    pub search_param: Option<String>,
    /// Valueset for the filter
    /// 
    /// The valueset for the code filter. The valueSet and code elements are
    /// additive. If valueSet is specified, the filter will return only those data
    /// items for which the value of the code-valued element specified in the path is
    /// a member of the specified valueset.
    /// 
    /// ## Cardinality: Optional (0..1)
    /// 
    /// ## Special Semantics
    /// - Included in summary
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement.codeFilter.valueSet")]
    #[fhir_serde(rename = "valueSet")]
    pub value_set: Option<Canonical>,
    /// What code is expected
    /// 
    /// The codes for the code filter. If values are given, the filter will return
    /// only those data items for which the code-valued attribute specified by the
    /// path has a value that is one of the specified codes. If codes are specified
    /// in addition to a value set, the filter returns items matching a code in the
    /// value set or one of the specified codes.
    /// 
    /// ## Cardinality: Optional, Multiple (0..*)
    /// 
    /// ## Special Semantics
    /// - Included in summary
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement.codeFilter.code")]
    pub code: Option<Vec<Coding>>,
}

/// Choice of types for the value\[x\] field in DataRequirementDateFilter
#[derive(Debug, Clone, PartialEq, FhirSerde, FhirPath)]
#[fhir_choice_element(base_name = "value")]
pub enum DataRequirementDateFilterValue {
    /// Variant accepting the DateTime type.
    #[fhir_serde(rename = "valueDateTime")]
    DateTime(DateTime),
    /// Variant accepting the Period type.
    #[fhir_serde(rename = "valuePeriod")]
    Period(Period),
    /// Variant accepting the Duration type.
    #[fhir_serde(rename = "valueDuration")]
    Duration(Duration),
}

/// What dates/date ranges are expected
/// 
/// Date filters specify additional constraints on the data in terms of the
/// applicable date range for specific elements. Each date filter specifies an
/// additional constraint on the data, i.e. date filters are AND'ed, not OR'ed.
/// 
/// ## Cardinality: Optional, Multiple (0..*)
/// 
/// ## Special Semantics
/// - Included in summary
/// 
/// ## Constraints
/// - **drq-2**: Either a path or a searchParam must be provided, but not both (error)
///   Expression: `path.exists() xor searchParam.exists()`
/// - **ele-1**: All FHIR elements must have a @value or children (error)
///   Expression: `hasValue() or (children().count() > id.count())`
#[derive(Debug, Clone, PartialEq, FhirSerde, FhirPath, Default, FhirValidate)]
#[fhir_resource(choice_elements = "value")]
#[fhir_invariant(key="drq-2", severity="error", human="Either a path or a searchParam must be provided, but not both", expr="path.exists() xor searchParam.exists()", path="DataRequirement.dateFilter")]
#[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement.dateFilter")]
pub struct DataRequirementDateFilter {
    /// Unique id for inter-element referencing
    /// 
    /// Unique id for the element within a resource (for internal references). This
    /// may be any string value that does not contain spaces.
    /// 
    /// ## Cardinality: Optional (0..1)
    pub id: Option<String>,
    /// Additional content defined by implementations
    /// 
    /// May be used to represent additional information that is not part of the basic
    /// definition of the element. To make the use of extensions safe and manageable,
    /// there is a strict set of governance applied to the definition and use of
    /// extensions. Though any implementer can define an extension, there is a set of
    /// requirements that SHALL be met as part of the definition of the extension.
    /// 
    /// ## Implementation Notes
    /// There can be no stigma associated with the use of extensions by any
    /// application, project, or standard - regardless of the institution or
    /// jurisdiction that uses or defines the extensions. The use of extensions is
    /// what allows the FHIR specification to retain a core level of simplicity for
    /// everyone.
    /// 
    /// ## Cardinality: Optional, Multiple (0..*)
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    /// - **ext-1**: Must have either extensions or value[x], not both (error)
    ///   Expression: `extension.exists() != value.exists()`
    /// 
    /// ## Aliases
    /// extensions, user content
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement.dateFilter.extension")]
    #[fhir_invariant(key="ext-1", severity="error", human="Must have either extensions or value[x], not both", expr="extension.exists() != value.exists()", path="DataRequirement.dateFilter.extension")]
    pub extension: Option<Vec<Extension>>,
    /// A date-valued attribute to filter on
    /// 
    /// The date-valued attribute of the filter. The specified path SHALL be a
    /// FHIRPath resolveable on the specified type of the DataRequirement, and SHALL
    /// consist only of identifiers, constant indexers, and .resolve(). The path is
    /// allowed to contain qualifiers (.) to traverse sub-elements, as well as
    /// indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple
    /// FHIRPath Profile](fhirpath.html#simple) for full details). Note that the
    /// index must be an integer constant. The path must resolve to an element of
    /// type date, dateTime, Period, Schedule, or Timing.
    /// 
    /// ## Implementation Notes
    /// The path attribute contains a [Simple FHIR Subset](fhirpath.html#simple) that
    /// allows path traversal, but not calculation.
    /// 
    /// ## Cardinality: Optional (0..1)
    /// 
    /// ## Special Semantics
    /// - Included in summary
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement.dateFilter.path")]
    pub path: Option<String>,
    /// A date valued parameter to search on
    /// 
    /// A date parameter that refers to a search parameter defined on the specified
    /// type of the DataRequirement, and which searches on elements of type date,
    /// dateTime, Period, Schedule, or Timing.
    /// 
    /// ## Cardinality: Optional (0..1)
    /// 
    /// ## Special Semantics
    /// - Included in summary
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement.dateFilter.searchParam")]
    #[fhir_serde(rename = "searchParam")]
    pub search_param: Option<String>,
    /// The value of the filter, as a Period, DateTime, or Duration value
    /// 
    /// The value of the filter. If period is specified, the filter will return only
    /// those data items that fall within the bounds determined by the Period,
    /// inclusive of the period boundaries. If dateTime is specified, the filter will
    /// return only those data items that are equal to the specified dateTime. If a
    /// Duration is specified, the filter will return only those data items that fall
    /// within Duration before now.
    /// 
    /// ## Cardinality: Optional (0..1)
    /// 
    /// ## Special Semantics
    /// - Included in summary
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement.dateFilter.value[x]")]
    #[fhir_serde(flatten)]
    pub value: Option<DataRequirementDateFilterValue>,
}

/// Order of the results
/// 
/// Specifies the order of the results to be returned.
/// 
/// ## Requirements
/// Enables the requirement "most recent 5 results" to be expressed.
/// 
/// ## Implementation Notes
/// This element can be used in combination with the sort element to specify
/// quota requirements such as "the most recent 5" or "the highest 5". When
/// multiple sorts are specified, they are applied in the order they appear in
/// the resource.
/// 
/// ## Cardinality: Optional, Multiple (0..*)
/// 
/// ## Special Semantics
/// - Included in summary
/// 
/// ## Constraints
/// - **ele-1**: All FHIR elements must have a @value or children (error)
///   Expression: `hasValue() or (children().count() > id.count())`
#[derive(Debug, Clone, PartialEq, FhirSerde, FhirPath, Default, FhirValidate)]
#[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement.sort")]
pub struct DataRequirementSort {
    /// Unique id for inter-element referencing
    /// 
    /// Unique id for the element within a resource (for internal references). This
    /// may be any string value that does not contain spaces.
    /// 
    /// ## Cardinality: Optional (0..1)
    pub id: Option<String>,
    /// Additional content defined by implementations
    /// 
    /// May be used to represent additional information that is not part of the basic
    /// definition of the element. To make the use of extensions safe and manageable,
    /// there is a strict set of governance applied to the definition and use of
    /// extensions. Though any implementer can define an extension, there is a set of
    /// requirements that SHALL be met as part of the definition of the extension.
    /// 
    /// ## Implementation Notes
    /// There can be no stigma associated with the use of extensions by any
    /// application, project, or standard - regardless of the institution or
    /// jurisdiction that uses or defines the extensions. The use of extensions is
    /// what allows the FHIR specification to retain a core level of simplicity for
    /// everyone.
    /// 
    /// ## Cardinality: Optional, Multiple (0..*)
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    /// - **ext-1**: Must have either extensions or value[x], not both (error)
    ///   Expression: `extension.exists() != value.exists()`
    /// 
    /// ## Aliases
    /// extensions, user content
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement.sort.extension")]
    #[fhir_invariant(key="ext-1", severity="error", human="Must have either extensions or value[x], not both", expr="extension.exists() != value.exists()", path="DataRequirement.sort.extension")]
    pub extension: Option<Vec<Extension>>,
    /// The name of the attribute to perform the sort
    /// 
    /// The attribute of the sort. The specified path must be resolvable from the
    /// type of the required data. The path is allowed to contain qualifiers (.) to
    /// traverse sub-elements, as well as indexers ([x]) to traverse
    /// multiple-cardinality sub-elements. Note that the index must be an integer
    /// constant.
    /// 
    /// ## Cardinality: Required (1..1)
    /// 
    /// ## Special Semantics
    /// - Included in summary
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement.sort.path")]
    pub path: String,
    /// ascending | descending
    /// 
    /// The direction of the sort, ascending or descending.
    /// 
    /// ## Cardinality: Required (1..1)
    /// 
    /// ## Special Semantics
    /// - Included in summary
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    /// 
    /// ## Binding
    /// - **Strength**: required
    /// - **Description**: The possible sort directions, ascending or descending.
    /// - **ValueSet**: http://hl7.org/fhir/ValueSet/sort-direction|4.0.1
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="DataRequirement.sort.direction")]
    pub direction: Code,
}

