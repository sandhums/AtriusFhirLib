// AUTO-GENERATED by atrius-fhir-generator (R4B Parameters)
use crate::r4b::*;

/// FHIR Parameters type
/// 
/// This resource is a non-persisted resource used to pass information into and
/// back from an [operation](operations.html). It has no other use, and there is
/// no RESTful endpoint associated with it.
/// 
/// ## Type: Resource type
/// Base type: http://hl7.org/fhir/StructureDefinition/Resource
/// 
/// ## Status: active
/// FHIR Version: 4.3.0
/// 
/// See: [Parameters](http://hl7.org/fhir/StructureDefinition/Parameters)
#[derive(Debug, Clone, PartialEq, FhirSerde, FhirPath, Default, FhirValidate)]
pub struct Parameters {
    /// Logical id of this artifact
    /// 
    /// The logical id of the resource, as used in the URL for the resource. Once
    /// assigned, this value never changes.
    /// 
    /// ## Implementation Notes
    /// The only time that a resource does not have an id is when it is being
    /// submitted to the server using a create operation.
    /// 
    /// ## Cardinality: Optional (0..1)
    /// 
    /// ## Special Semantics
    /// - Included in summary
    pub id: Option<String>,
    /// Metadata about the resource
    /// 
    /// The metadata about the resource. This is content that is maintained by the
    /// infrastructure. Changes to the content might not always be associated with
    /// version changes to the resource.
    /// 
    /// ## Cardinality: Optional (0..1)
    /// 
    /// ## Special Semantics
    /// - Included in summary
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="Parameters.meta")]
    pub meta: Option<Meta>,
    /// A set of rules under which this content was created
    /// 
    /// A reference to a set of rules that were followed when the resource was
    /// constructed, and which must be understood when processing the content. Often,
    /// this is a reference to an implementation guide that defines the special rules
    /// along with other profiles etc.
    /// 
    /// ## Implementation Notes
    /// Asserting this rule set restricts the content to be only understood by a
    /// limited set of trading partners. This inherently limits the usefulness of the
    /// data in the long term. However, the existing health eco-system is highly
    /// fractured, and not yet ready to define, collect, and exchange data in a
    /// generally computable sense. Wherever possible, implementers and/or
    /// specification writers should avoid using this element. Often, when used, the
    /// URL is a reference to an implementation guide that defines these special
    /// rules as part of it's narrative along with other profiles, value sets, etc.
    /// 
    /// ## Cardinality: Optional (0..1)
    /// 
    /// ## Special Semantics
    /// - Modifier element - This element is labeled as a modifier because the implicit rules may provide additional knowledge about the resource that modifies it's meaning or interpretation
    /// - Included in summary
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="Parameters.implicitRules")]
    #[fhir_serde(rename = "implicitRules")]
    pub implicit_rules: Option<Uri>,
    /// Language of the resource content
    /// 
    /// The base language in which the resource is written.
    /// 
    /// ## Implementation Notes
    /// Language is provided to support indexing and accessibility (typically,
    /// services such as text to speech use the language tag). The html language tag
    /// in the narrative applies to the narrative. The language tag on the resource
    /// may be used to specify the language of other presentations generated from the
    /// data in the resource. Not all the content has to be in the base language. The
    /// Resource.language should not be assumed to apply to the narrative
    /// automatically. If a language is specified, it should it also be specified on
    /// the div element in the html (see rules in HTML5 for information about the
    /// relationship between xml:lang and the html lang attribute).
    /// 
    /// ## Cardinality: Optional (0..1)
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    /// 
    /// ## Binding
    /// - **Strength**: preferred
    /// - **Description**: IETF language tag
    /// - **ValueSet**: http://hl7.org/fhir/ValueSet/languages
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="Parameters.language")]
    pub language: Option<Code>,
    /// Operation Parameter
    /// 
    /// A parameter passed to or received from the operation.
    /// 
    /// ## Cardinality: Optional, Multiple (0..*)
    /// 
    /// ## Special Semantics
    /// - Included in summary
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children unless an empty Parameters resource (error)
    ///   Expression: `hasValue() or (children().count() > id.count()) or $this is Parameters`
    /// - **inv-1**: A parameter must have one and only one of (value, resource, part) (error)
    ///   Expression: `(part.exists() and value.empty() and resource.empty()) or (part.empty() and (value.exists() xor resource.exists()))`
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children unless an empty Parameters resource", expr="hasValue() or (children().count() > id.count()) or $this is Parameters", path="Parameters.parameter")]
    #[fhir_invariant(key="inv-1", severity="error", human="A parameter must have one and only one of (value, resource, part)", expr="(part.exists() and value.empty() and resource.empty()) or (part.empty() and (value.exists() xor resource.exists()))", path="Parameters.parameter")]
    pub parameter: Option<Vec<ParametersParameter>>,
}

/// Choice of types for the value\[x\] field in ParametersParameter
#[derive(Debug, Clone, PartialEq, FhirSerde, FhirPath)]
#[fhir_choice_element(base_name = "value")]
pub enum ParametersParameterValue {
    /// Variant accepting the Base64Binary type.
    #[fhir_serde(rename = "valueBase64Binary")]
    Base64Binary(Base64Binary),
    /// Variant accepting the Boolean type.
    #[fhir_serde(rename = "valueBoolean")]
    Boolean(Boolean),
    /// Variant accepting the Canonical type.
    #[fhir_serde(rename = "valueCanonical")]
    Canonical(Canonical),
    /// Variant accepting the Code type.
    #[fhir_serde(rename = "valueCode")]
    Code(Code),
    /// Variant accepting the Date type.
    #[fhir_serde(rename = "valueDate")]
    Date(Date),
    /// Variant accepting the DateTime type.
    #[fhir_serde(rename = "valueDateTime")]
    DateTime(DateTime),
    /// Variant accepting the Decimal type.
    #[fhir_serde(rename = "valueDecimal")]
    Decimal(Decimal),
    /// Variant accepting the Id type.
    #[fhir_serde(rename = "valueId")]
    Id(Id),
    /// Variant accepting the Instant type.
    #[fhir_serde(rename = "valueInstant")]
    Instant(Instant),
    /// Variant accepting the Integer type.
    #[fhir_serde(rename = "valueInteger")]
    Integer(Integer),
    /// Variant accepting the Markdown type.
    #[fhir_serde(rename = "valueMarkdown")]
    Markdown(Markdown),
    /// Variant accepting the Oid type.
    #[fhir_serde(rename = "valueOid")]
    Oid(Oid),
    /// Variant accepting the PositiveInt type.
    #[fhir_serde(rename = "valuePositiveInt")]
    PositiveInt(PositiveInt),
    /// Variant accepting the String type.
    #[fhir_serde(rename = "valueString")]
    String(String),
    /// Variant accepting the Time type.
    #[fhir_serde(rename = "valueTime")]
    Time(Time),
    /// Variant accepting the UnsignedInt type.
    #[fhir_serde(rename = "valueUnsignedInt")]
    UnsignedInt(UnsignedInt),
    /// Variant accepting the Uri type.
    #[fhir_serde(rename = "valueUri")]
    Uri(Uri),
    /// Variant accepting the Url type.
    #[fhir_serde(rename = "valueUrl")]
    Url(Url),
    /// Variant accepting the Uuid type.
    #[fhir_serde(rename = "valueUuid")]
    Uuid(Uuid),
    /// Variant accepting the Address type.
    #[fhir_serde(rename = "valueAddress")]
    Address(Address),
    /// Variant accepting the Age type.
    #[fhir_serde(rename = "valueAge")]
    Age(Age),
    /// Variant accepting the Annotation type.
    #[fhir_serde(rename = "valueAnnotation")]
    Annotation(Annotation),
    /// Variant accepting the Attachment type.
    #[fhir_serde(rename = "valueAttachment")]
    Attachment(Attachment),
    /// Variant accepting the CodeableConcept type.
    #[fhir_serde(rename = "valueCodeableConcept")]
    CodeableConcept(CodeableConcept),
    /// Variant accepting the Coding type.
    #[fhir_serde(rename = "valueCoding")]
    Coding(Coding),
    /// Variant accepting the ContactPoint type.
    #[fhir_serde(rename = "valueContactPoint")]
    ContactPoint(ContactPoint),
    /// Variant accepting the Count type.
    #[fhir_serde(rename = "valueCount")]
    Count(Count),
    /// Variant accepting the Distance type.
    #[fhir_serde(rename = "valueDistance")]
    Distance(Distance),
    /// Variant accepting the Duration type.
    #[fhir_serde(rename = "valueDuration")]
    Duration(Duration),
    /// Variant accepting the HumanName type.
    #[fhir_serde(rename = "valueHumanName")]
    HumanName(HumanName),
    /// Variant accepting the Identifier type.
    #[fhir_serde(rename = "valueIdentifier")]
    Identifier(Identifier),
    /// Variant accepting the Money type.
    #[fhir_serde(rename = "valueMoney")]
    Money(Money),
    /// Variant accepting the Period type.
    #[fhir_serde(rename = "valuePeriod")]
    Period(Period),
    /// Variant accepting the Quantity type.
    #[fhir_serde(rename = "valueQuantity")]
    Quantity(Quantity),
    /// Variant accepting the Range type.
    #[fhir_serde(rename = "valueRange")]
    Range(Range),
    /// Variant accepting the Ratio type.
    #[fhir_serde(rename = "valueRatio")]
    Ratio(Ratio),
    /// Variant accepting the Reference type.
    #[fhir_serde(rename = "valueReference")]
    Reference(Reference),
    /// Variant accepting the SampledData type.
    #[fhir_serde(rename = "valueSampledData")]
    SampledData(SampledData),
    /// Variant accepting the Signature type.
    #[fhir_serde(rename = "valueSignature")]
    Signature(Signature),
    /// Variant accepting the Timing type.
    #[fhir_serde(rename = "valueTiming")]
    Timing(Timing),
    /// Variant accepting the ContactDetail type.
    #[fhir_serde(rename = "valueContactDetail")]
    ContactDetail(ContactDetail),
    /// Variant accepting the Contributor type.
    #[fhir_serde(rename = "valueContributor")]
    Contributor(Contributor),
    /// Variant accepting the DataRequirement type.
    #[fhir_serde(rename = "valueDataRequirement")]
    DataRequirement(DataRequirement),
    /// Variant accepting the Expression type.
    #[fhir_serde(rename = "valueExpression")]
    Expression(Expression),
    /// Variant accepting the ParameterDefinition type.
    #[fhir_serde(rename = "valueParameterDefinition")]
    ParameterDefinition(ParameterDefinition),
    /// Variant accepting the RelatedArtifact type.
    #[fhir_serde(rename = "valueRelatedArtifact")]
    RelatedArtifact(RelatedArtifact),
    /// Variant accepting the TriggerDefinition type.
    #[fhir_serde(rename = "valueTriggerDefinition")]
    TriggerDefinition(TriggerDefinition),
    /// Variant accepting the UsageContext type.
    #[fhir_serde(rename = "valueUsageContext")]
    UsageContext(UsageContext),
    /// Variant accepting the Dosage type.
    #[fhir_serde(rename = "valueDosage")]
    Dosage(Dosage),
    /// Variant accepting the Meta type.
    #[fhir_serde(rename = "valueMeta")]
    Meta(Meta),
}

/// Operation Parameter
/// 
/// A parameter passed to or received from the operation.
/// 
/// ## Cardinality: Optional, Multiple (0..*)
/// 
/// ## Special Semantics
/// - Included in summary
/// 
/// ## Constraints
/// - **ele-1**: All FHIR elements must have a @value or children unless an empty Parameters resource (error)
///   Expression: `hasValue() or (children().count() > id.count()) or $this is Parameters`
/// - **inv-1**: A parameter must have one and only one of (value, resource, part) (error)
///   Expression: `(part.exists() and value.empty() and resource.empty()) or (part.empty() and (value.exists() xor resource.exists()))`
#[derive(Debug, Clone, PartialEq, FhirSerde, FhirPath, Default, FhirValidate)]
#[fhir_resource(choice_elements = "value")]
#[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children unless an empty Parameters resource", expr="hasValue() or (children().count() > id.count()) or $this is Parameters", path="Parameters.parameter")]
#[fhir_invariant(key="inv-1", severity="error", human="A parameter must have one and only one of (value, resource, part)", expr="(part.exists() and value.empty() and resource.empty()) or (part.empty() and (value.exists() xor resource.exists()))", path="Parameters.parameter")]
pub struct ParametersParameter {
    /// Unique id for inter-element referencing
    /// 
    /// Unique id for the element within a resource (for internal references). This
    /// may be any string value that does not contain spaces.
    /// 
    /// ## Cardinality: Optional (0..1)
    pub id: Option<String>,
    /// Additional content defined by implementations
    /// 
    /// May be used to represent additional information that is not part of the basic
    /// definition of the element. To make the use of extensions safe and manageable,
    /// there is a strict set of governance applied to the definition and use of
    /// extensions. Though any implementer can define an extension, there is a set of
    /// requirements that SHALL be met as part of the definition of the extension.
    /// 
    /// ## Implementation Notes
    /// There can be no stigma associated with the use of extensions by any
    /// application, project, or standard - regardless of the institution or
    /// jurisdiction that uses or defines the extensions. The use of extensions is
    /// what allows the FHIR specification to retain a core level of simplicity for
    /// everyone.
    /// 
    /// ## Cardinality: Optional, Multiple (0..*)
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    /// - **ext-1**: Must have either extensions or value[x], not both (error)
    ///   Expression: `extension.exists() != value.exists()`
    /// 
    /// ## Aliases
    /// extensions, user content
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="Parameters.parameter.extension")]
    #[fhir_invariant(key="ext-1", severity="error", human="Must have either extensions or value[x], not both", expr="extension.exists() != value.exists()", path="Parameters.parameter.extension")]
    pub extension: Option<Vec<Extension>>,
    /// Extensions that cannot be ignored even if unrecognized
    /// 
    /// May be used to represent additional information that is not part of the basic
    /// definition of the element and that modifies the understanding of the element
    /// in which it is contained and/or the understanding of the containing element's
    /// descendants. Usually modifier elements provide negation or qualification. To
    /// make the use of extensions safe and manageable, there is a strict set of
    /// governance applied to the definition and use of extensions. Though any
    /// implementer can define an extension, there is a set of requirements that
    /// SHALL be met as part of the definition of the extension. Applications
    /// processing a resource are required to check for modifier extensions.
    /// 
    /// Modifier extensions SHALL NOT change the meaning of any elements on Resource
    /// or DomainResource (including cannot change the meaning of modifierExtension
    /// itself).
    /// 
    /// ## Requirements
    /// Modifier extensions allow for extensions that *cannot* be safely ignored to
    /// be clearly distinguished from the vast majority of extensions which can be
    /// safely ignored. This promotes interoperability by eliminating the need for
    /// implementers to prohibit the presence of extensions. For further information,
    /// see the [definition of modifier
    /// extensions](extensibility.html#modifierExtension).
    /// 
    /// ## Implementation Notes
    /// There can be no stigma associated with the use of extensions by any
    /// application, project, or standard - regardless of the institution or
    /// jurisdiction that uses or defines the extensions. The use of extensions is
    /// what allows the FHIR specification to retain a core level of simplicity for
    /// everyone.
    /// 
    /// ## Cardinality: Optional, Multiple (0..*)
    /// 
    /// ## Special Semantics
    /// - Modifier element - Modifier extensions are expected to modify the meaning or interpretation of the element that contains them
    /// - Included in summary
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    /// - **ext-1**: Must have either extensions or value[x], not both (error)
    ///   Expression: `extension.exists() != value.exists()`
    /// 
    /// ## Aliases
    /// extensions, user content, modifiers
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="Parameters.parameter.modifierExtension")]
    #[fhir_invariant(key="ext-1", severity="error", human="Must have either extensions or value[x], not both", expr="extension.exists() != value.exists()", path="Parameters.parameter.modifierExtension")]
    #[fhir_serde(rename = "modifierExtension")]
    pub modifier_extension: Option<Vec<Extension>>,
    /// Name from the definition
    /// 
    /// The name of the parameter (reference to the operation definition).
    /// 
    /// ## Cardinality: Required (1..1)
    /// 
    /// ## Special Semantics
    /// - Included in summary
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="Parameters.parameter.name")]
    pub name: String,
    /// If parameter is a data type
    /// 
    /// Conveys the content if the parameter is a data type.
    /// 
    /// ## Cardinality: Optional (0..1)
    /// 
    /// ## Special Semantics
    /// - Included in summary
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    /// 
    /// ## Conditions
    /// Used when: inv-1
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="Parameters.parameter.value[x]")]
    #[fhir_serde(flatten)]
    pub value: Option<ParametersParameterValue>,
    /// If parameter is a whole resource
    /// 
    /// If the parameter is a whole resource.
    /// 
    /// ## Implementation Notes
    /// When resolving references in resources, the operation definition may specify
    /// how references may be resolved between parameters. If a reference cannot be
    /// resolved between the parameters, the application should fall back to it's
    /// general resource resolution methods.
    /// 
    /// ## Cardinality: Optional (0..1)
    /// 
    /// ## Special Semantics
    /// - Included in summary
    /// 
    /// ## Conditions
    /// Used when: inv-1
    pub resource: Option<Resource>,
    /// Named part of a multi-part parameter
    /// 
    /// A named part of a multi-part parameter.
    /// 
    /// ## Implementation Notes
    /// Only one level of nested parameters is allowed.
    /// 
    /// ## Cardinality: Optional, Multiple (0..*)
    /// 
    /// ## Special Semantics
    /// - Included in summary
    /// 
    /// ## Constraints
    /// - **ele-1**: All FHIR elements must have a @value or children (error)
    ///   Expression: `hasValue() or (children().count() > id.count())`
    #[fhir_invariant(key="ele-1", severity="error", human="All FHIR elements must have a @value or children", expr="hasValue() or (children().count() > id.count())", path="Parameters.parameter.part")]
    pub part: Option<Vec<ParametersParameter>>,
}

