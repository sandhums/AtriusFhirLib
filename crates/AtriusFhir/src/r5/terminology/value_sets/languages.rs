// @generated by AtriusValueSetGenerator
// DO NOT EDIT MANUALLY

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(clippy::upper_case_acronyms)]

use super::super::super::{Code, CodeableConcept, Coding, Element, Uri};

use super::super::super::string::String as FhirString;

///FHIR ValueSet: CommonLanguages
///Canonical URL: http://hl7.org/fhir/ValueSet/languages
///Version: 5.0.0
///Title: Common Languages
///Status: active
///This value set includes common codes from BCP-47 (see http://tools.ietf.org/html/bcp47)
///Compose includes 82 explicit concept codes
///Includes systems:
///- urn:ietf:bcp:47
pub struct CommonLanguages;
impl CommonLanguages {
    pub const URL: &'static str = "http://hl7.org/fhir/ValueSet/languages";
    pub const HAS_NONLOCAL_RULES: bool = false;
    pub fn version() -> Option<&'static str> {
        Some("5.0.0")
    }
    pub fn include_systems() -> &'static [&'static str] {
        &["urn:ietf:bcp:47"]
    }
    pub fn include_value_sets() -> &'static [&'static str] {
        &[]
    }
    /// Systems that are included as whole CodeSystems but are not locally enumerable.
    ///
    /// If this is non-empty, callers should use a terminology server for definitive validation.
    pub fn include_whole_systems() -> &'static [&'static str] {
        &[]
    }
    /// Returns true only when this ValueSet can be treated as fully locally checkable.
    ///
    /// If `HAS_NONLOCAL_RULES` is true (filters, include.valueSet, or non-enumerated whole-system includes),
    /// local checks are best-effort and may require a terminology server.
    pub fn is_locally_enumerated() -> bool {
        !Self::HAS_NONLOCAL_RULES
            && (!Self::expansion_pairs().is_empty() || !Self::include_pairs().is_empty())
    }
    fn include_pairs() -> &'static [(&'static str, &'static str)] {
        &[
            ("urn:ietf:bcp:47", "ar"),
            ("urn:ietf:bcp:47", "bg"),
            ("urn:ietf:bcp:47", "bg-BG"),
            ("urn:ietf:bcp:47", "bn"),
            ("urn:ietf:bcp:47", "cs"),
            ("urn:ietf:bcp:47", "cs-CZ"),
            ("urn:ietf:bcp:47", "bs"),
            ("urn:ietf:bcp:47", "bs-BA"),
            ("urn:ietf:bcp:47", "da"),
            ("urn:ietf:bcp:47", "da-DK"),
            ("urn:ietf:bcp:47", "de"),
            ("urn:ietf:bcp:47", "de-AT"),
            ("urn:ietf:bcp:47", "de-CH"),
            ("urn:ietf:bcp:47", "de-DE"),
            ("urn:ietf:bcp:47", "el"),
            ("urn:ietf:bcp:47", "el-GR"),
            ("urn:ietf:bcp:47", "en"),
            ("urn:ietf:bcp:47", "en-AU"),
            ("urn:ietf:bcp:47", "en-CA"),
            ("urn:ietf:bcp:47", "en-GB"),
            ("urn:ietf:bcp:47", "en-IN"),
            ("urn:ietf:bcp:47", "en-NZ"),
            ("urn:ietf:bcp:47", "en-SG"),
            ("urn:ietf:bcp:47", "en-US"),
            ("urn:ietf:bcp:47", "es"),
            ("urn:ietf:bcp:47", "es-AR"),
            ("urn:ietf:bcp:47", "es-ES"),
            ("urn:ietf:bcp:47", "es-UY"),
            ("urn:ietf:bcp:47", "et"),
            ("urn:ietf:bcp:47", "et-EE"),
            ("urn:ietf:bcp:47", "fi"),
            ("urn:ietf:bcp:47", "fr"),
            ("urn:ietf:bcp:47", "fr-BE"),
            ("urn:ietf:bcp:47", "fr-CH"),
            ("urn:ietf:bcp:47", "fr-FR"),
            ("urn:ietf:bcp:47", "fi-FI"),
            ("urn:ietf:bcp:47", "fr-CA"),
            ("urn:ietf:bcp:47", "fy"),
            ("urn:ietf:bcp:47", "fy-NL"),
            ("urn:ietf:bcp:47", "hi"),
            ("urn:ietf:bcp:47", "hr"),
            ("urn:ietf:bcp:47", "hr-HR"),
            ("urn:ietf:bcp:47", "is"),
            ("urn:ietf:bcp:47", "is-IS"),
            ("urn:ietf:bcp:47", "it"),
            ("urn:ietf:bcp:47", "it-CH"),
            ("urn:ietf:bcp:47", "it-IT"),
            ("urn:ietf:bcp:47", "ja"),
            ("urn:ietf:bcp:47", "ko"),
            ("urn:ietf:bcp:47", "lt"),
            ("urn:ietf:bcp:47", "lt-LT"),
            ("urn:ietf:bcp:47", "lv"),
            ("urn:ietf:bcp:47", "lv-LV"),
            ("urn:ietf:bcp:47", "nl"),
            ("urn:ietf:bcp:47", "nl-BE"),
            ("urn:ietf:bcp:47", "nl-NL"),
            ("urn:ietf:bcp:47", "no"),
            ("urn:ietf:bcp:47", "no-NO"),
            ("urn:ietf:bcp:47", "pa"),
            ("urn:ietf:bcp:47", "pl"),
            ("urn:ietf:bcp:47", "pl-PL"),
            ("urn:ietf:bcp:47", "pt"),
            ("urn:ietf:bcp:47", "pt-PT"),
            ("urn:ietf:bcp:47", "pt-BR"),
            ("urn:ietf:bcp:47", "ro"),
            ("urn:ietf:bcp:47", "ro-RO"),
            ("urn:ietf:bcp:47", "ru"),
            ("urn:ietf:bcp:47", "ru-RU"),
            ("urn:ietf:bcp:47", "sk"),
            ("urn:ietf:bcp:47", "sk-SK"),
            ("urn:ietf:bcp:47", "sl"),
            ("urn:ietf:bcp:47", "sl-SI"),
            ("urn:ietf:bcp:47", "sr"),
            ("urn:ietf:bcp:47", "sr-RS"),
            ("urn:ietf:bcp:47", "sv"),
            ("urn:ietf:bcp:47", "sv-SE"),
            ("urn:ietf:bcp:47", "te"),
            ("urn:ietf:bcp:47", "zh"),
            ("urn:ietf:bcp:47", "zh-CN"),
            ("urn:ietf:bcp:47", "zh-HK"),
            ("urn:ietf:bcp:47", "zh-SG"),
            ("urn:ietf:bcp:47", "zh-TW"),
        ]
    }
    fn include_entries() -> &'static [(
        &'static str,
        &'static str,
        Option<&'static str>,
        Option<&'static str>,
    )] {
        &[
            ("urn:ietf:bcp:47", "ar", Some("Arabic"), None),
            ("urn:ietf:bcp:47", "bg", Some("Bulgarian"), None),
            ("urn:ietf:bcp:47", "bg-BG", Some("Bulgarian (Bulgaria)"), None),
            ("urn:ietf:bcp:47", "bn", Some("Bengali"), None),
            ("urn:ietf:bcp:47", "bs", Some("Bosnian"), None),
            ("urn:ietf:bcp:47", "bs-BA", Some("Bosnian (Bosnia and Herzegovina)"), None),
            ("urn:ietf:bcp:47", "cs", Some("Czech"), None),
            ("urn:ietf:bcp:47", "cs-CZ", Some("Czech (Czechia)"), None),
            ("urn:ietf:bcp:47", "da", Some("Danish"), None),
            ("urn:ietf:bcp:47", "da-DK", Some("Danish (Denmark)"), None),
            ("urn:ietf:bcp:47", "de", Some("German"), None),
            ("urn:ietf:bcp:47", "de-AT", Some("German (Austria)"), None),
            ("urn:ietf:bcp:47", "de-CH", Some("German (Switzerland)"), None),
            ("urn:ietf:bcp:47", "de-DE", Some("German (Germany)"), None),
            ("urn:ietf:bcp:47", "el", Some("Greek"), None),
            ("urn:ietf:bcp:47", "el-GR", Some("Greek (Greece)"), None),
            ("urn:ietf:bcp:47", "en", Some("English"), None),
            ("urn:ietf:bcp:47", "en-AU", Some("English (Australia)"), None),
            ("urn:ietf:bcp:47", "en-CA", Some("English (Canada)"), None),
            ("urn:ietf:bcp:47", "en-GB", Some("English (Great Britain)"), None),
            ("urn:ietf:bcp:47", "en-IN", Some("English (India)"), None),
            ("urn:ietf:bcp:47", "en-NZ", Some("English (New Zealand)"), None),
            ("urn:ietf:bcp:47", "en-SG", Some("English (Singapore)"), None),
            ("urn:ietf:bcp:47", "en-US", Some("English (United States)"), None),
            ("urn:ietf:bcp:47", "es", Some("Spanish"), None),
            ("urn:ietf:bcp:47", "es-AR", Some("Spanish (Argentina)"), None),
            ("urn:ietf:bcp:47", "es-ES", Some("Spanish (Spain)"), None),
            ("urn:ietf:bcp:47", "es-UY", Some("Spanish (Uruguay)"), None),
            ("urn:ietf:bcp:47", "et", Some("Estonian"), None),
            ("urn:ietf:bcp:47", "et-EE", Some("Estonian (Estonia)"), None),
            ("urn:ietf:bcp:47", "fi", Some("Finnish"), None),
            ("urn:ietf:bcp:47", "fi-FI", Some("Finnish (Finland)"), None),
            ("urn:ietf:bcp:47", "fr", Some("French"), None),
            ("urn:ietf:bcp:47", "fr-BE", Some("French (Belgium)"), None),
            ("urn:ietf:bcp:47", "fr-CA", Some("French (Canada)"), None),
            ("urn:ietf:bcp:47", "fr-CH", Some("French (Switzerland)"), None),
            ("urn:ietf:bcp:47", "fr-FR", Some("French (France)"), None),
            ("urn:ietf:bcp:47", "fy", Some("Frisian"), None),
            ("urn:ietf:bcp:47", "fy-NL", Some("Frisian (Netherlands)"), None),
            ("urn:ietf:bcp:47", "hi", Some("Hindi"), None),
            ("urn:ietf:bcp:47", "hr", Some("Croatian"), None),
            ("urn:ietf:bcp:47", "hr-HR", Some("Croatian (Croatia)"), None),
            ("urn:ietf:bcp:47", "is", Some("Icelandic"), None),
            ("urn:ietf:bcp:47", "is-IS", Some("Icelandic (Iceland)"), None),
            ("urn:ietf:bcp:47", "it", Some("Italian"), None),
            ("urn:ietf:bcp:47", "it-CH", Some("Italian (Switzerland)"), None),
            ("urn:ietf:bcp:47", "it-IT", Some("Italian (Italy)"), None),
            ("urn:ietf:bcp:47", "ja", Some("Japanese"), None),
            ("urn:ietf:bcp:47", "ko", Some("Korean"), None),
            ("urn:ietf:bcp:47", "lt", Some("Lithuanian"), None),
            ("urn:ietf:bcp:47", "lt-LT", Some("Lithuanian (Lithuania)"), None),
            ("urn:ietf:bcp:47", "lv", Some("Latvian"), None),
            ("urn:ietf:bcp:47", "lv-LV", Some("Latvian (Latvia)"), None),
            ("urn:ietf:bcp:47", "nl", Some("Dutch"), None),
            ("urn:ietf:bcp:47", "nl-BE", Some("Dutch (Belgium)"), None),
            ("urn:ietf:bcp:47", "nl-NL", Some("Dutch (Netherlands)"), None),
            ("urn:ietf:bcp:47", "no", Some("Norwegian"), None),
            ("urn:ietf:bcp:47", "no-NO", Some("Norwegian (Norway)"), None),
            ("urn:ietf:bcp:47", "pa", Some("Punjabi"), None),
            ("urn:ietf:bcp:47", "pl", Some("Polish"), None),
            ("urn:ietf:bcp:47", "pl-PL", Some("Polish (Poland)"), None),
            ("urn:ietf:bcp:47", "pt", Some("Portuguese"), None),
            ("urn:ietf:bcp:47", "pt-BR", Some("Portuguese (Brazil)"), None),
            ("urn:ietf:bcp:47", "pt-PT", Some("Portuguese (Portugal)"), None),
            ("urn:ietf:bcp:47", "ro", Some("Romanian"), None),
            ("urn:ietf:bcp:47", "ro-RO", Some("Romanian (Romania)"), None),
            ("urn:ietf:bcp:47", "ru", Some("Russian"), None),
            ("urn:ietf:bcp:47", "ru-RU", Some("Russian (Russia)"), None),
            ("urn:ietf:bcp:47", "sk", Some("Slovakian"), None),
            ("urn:ietf:bcp:47", "sk-SK", Some("Slovakian (Slovakia)"), None),
            ("urn:ietf:bcp:47", "sl", Some("Slovenian"), None),
            ("urn:ietf:bcp:47", "sl-SI", Some("Slovenian (Slovenia)"), None),
            ("urn:ietf:bcp:47", "sr", Some("Serbian"), None),
            ("urn:ietf:bcp:47", "sr-RS", Some("Serbian (Serbia)"), None),
            ("urn:ietf:bcp:47", "sv", Some("Swedish"), None),
            ("urn:ietf:bcp:47", "sv-SE", Some("Swedish (Sweden)"), None),
            ("urn:ietf:bcp:47", "te", Some("Telugu"), None),
            ("urn:ietf:bcp:47", "zh", Some("Chinese"), None),
            ("urn:ietf:bcp:47", "zh-CN", Some("Chinese (China)"), None),
            ("urn:ietf:bcp:47", "zh-HK", Some("Chinese (Hong Kong)"), None),
            ("urn:ietf:bcp:47", "zh-SG", Some("Chinese (Singapore)"), None),
            ("urn:ietf:bcp:47", "zh-TW", Some("Chinese (Taiwan)"), None),
        ]
    }
    /// Return the preferred display text for a (system, code) pair, if present in this ValueSet's explicit concepts.
    pub fn display(system: &str, code: &str) -> Option<&'static str> {
        for (s, c, d, _def) in Self::include_entries() {
            if *s == system && *c == code {
                return *d;
            }
        }
        None
    }
    /// Return the ValueSet concept definition for a (system, code) pair, if present.
    ///
    /// In `valuesets.json` this often comes from the extension:
    /// `http://hl7.org/fhir/StructureDefinition/valueset-concept-definition`.
    pub fn definition(system: &str, code: &str) -> Option<&'static str> {
        for (s, c, _d, def) in Self::include_entries() {
            if *s == system && *c == code {
                return *def;
            }
        }
        None
    }
    /// Create a minimal `Coding` from a (system, code) pair.
    ///
    /// If this ValueSet provides an explicit display for the code, it will be populated.
    pub fn to_coding(system: &str, code: &str) -> Coding {
        let sys_uri: Uri = Element {
            id: None,
            extension: None,
            value: Some(system.to_string()),
        };
        let code_el: Code = Element {
            id: None,
            extension: None,
            value: Some(code.to_string()),
        };
        let display = Self::display(system, code)
            .map(|s| FhirString {
                id: None,
                extension: None,
                value: Some(s.to_string()),
            });
        Coding {
            id: None,
            extension: None,
            system: Some(sys_uri),
            version: Self::version()
                .map(|v| FhirString {
                    id: None,
                    extension: None,
                    value: Some(v.to_string()),
                }),
            code: Some(code_el),
            display,
            user_selected: None,
        }
    }
    fn exclude_pairs() -> &'static [(&'static str, &'static str)] {
        &[]
    }
    fn expansion_pairs() -> &'static [(&'static str, &'static str)] {
        &[]
    }
    /// Best-effort local validation for a `Coding` against this ValueSet.
    ///
    /// Rules:
    /// - Explicit excludes (compose.exclude.concept) always deny.
    /// - If expansion.contains exists, it is treated as an explicit allow-list.
    /// - Else if compose.include.concept exists, it is treated as an explicit allow-list.
    /// - Else: fall back to whole-system validation when possible (generated CodeSystem enums / RGB grammar).
    ///
    /// Note: terminology filters and include.valueSet references are NOT evaluated locally.
    pub fn contains_coding(coding: &Coding) -> bool {
        let system = match &coding.system {
            Some(s) => s.value.as_deref().unwrap_or(""),
            None => return false,
        };
        let code = match &coding.code {
            Some(c) => c.value.as_deref().unwrap_or(""),
            None => return false,
        };
        if Self::exclude_pairs().iter().any(|(s, c)| *s == system && *c == code) {
            return false;
        }
        let exp = Self::expansion_pairs();
        if !exp.is_empty() {
            return exp.iter().any(|(s, c)| *s == system && *c == code);
        }
        let inc = Self::include_pairs();
        if !inc.is_empty() {
            return inc.iter().any(|(s, c)| *s == system && *c == code);
        }
        match system {
            _ => false,
        }
    }
    /// Best-effort local validation for a `CodeableConcept` against this ValueSet.
    ///
    /// Returns true if any `coding` entry is contained in the ValueSet.
    pub fn contains_codeable_concept(cc: &CodeableConcept) -> bool {
        match cc.coding.as_ref() {
            Some(codings) => codings.iter().any(|c| Self::contains_coding(c)),
            None => false,
        }
    }
    /// Convenience: validate a FHIR `code` primitive when the binding is on `code`.
    ///
    /// This only works reliably when the ValueSet includes exactly one system.
    pub fn contains_code(code: &Code) -> bool {
        let code_str = match code.value.as_deref() {
            Some(v) => v,
            None => return false,
        };
        let systems = Self::include_systems();
        if systems.len() != 1 {
            return false;
        }
        let system: Uri = Element {
            id: None,
            extension: None,
            value: Some(systems[0].to_string()),
        };
        let code: Code = Element {
            id: None,
            extension: None,
            value: Some(code_str.to_string()),
        };
        let coding = Coding {
            id: None,
            extension: None,
            system: Some(system),
            version: None,
            code: Some(code),
            display: None,
            user_selected: None,
        };
        Self::contains_coding(&coding)
    }
    /// Create a minimal `CodeableConcept` (single coding) from a (system, code) pair.
    pub fn to_codeable_concept(system: &str, code: &str) -> CodeableConcept {
        let coding = Self::to_coding(system, code);
        CodeableConcept {
            id: None,
            extension: None,
            coding: Some(vec![coding]),
            text: None,
        }
    }
}
impl super::super::bindings::ValueSetMembership<Code> for CommonLanguages {
    fn contains(v: &Code) -> bool {
        Self::contains_code(v)
    }
}
impl super::super::bindings::ValueSetMembership<Coding> for CommonLanguages {
    fn contains(v: &Coding) -> bool {
        Self::contains_coding(v)
    }
}
impl super::super::bindings::ValueSetMembership<CodeableConcept> for CommonLanguages {
    fn contains(v: &CodeableConcept) -> bool {
        Self::contains_codeable_concept(v)
    }
}
fn is_rgb_hex(code: &str) -> bool {
    let b = code.as_bytes();
    if b.len() != 7 || b[0] != b'#' {
        return false;
    }
    fn is_hex(x: u8) -> bool {
        (b'0'..=b'9').contains(&x) || (b'a'..=b'f').contains(&x)
            || (b'A'..=b'F').contains(&x)
    }
    is_hex(b[1]) && is_hex(b[2]) && is_hex(b[3]) && is_hex(b[4]) && is_hex(b[5])
        && is_hex(b[6])
}

