// @generated by AtriusValueSetGenerator
// DO NOT EDIT MANUALLY

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(clippy::upper_case_acronyms)]

use super::super::super::{Code, CodeableConcept, Coding, Element, Uri};

use super::super::super::string::String as FhirString;

///FHIR ValueSet: ContributorSummaryStyle
///Canonical URL: http://hl7.org/fhir/ValueSet/contributor-summary-style
///Version: 5.0.0
///Title: Contributor Summary Style
///Status: draft
///Used to code the format of the display string.
///Compose includes 16 explicit concept codes
///Includes systems:
///- http://hl7.org/fhir/contributor-summary-style
pub struct ContributorSummaryStyle;
impl ContributorSummaryStyle {
    pub const URL: &'static str = "http://hl7.org/fhir/ValueSet/contributor-summary-style";
    pub const HAS_NONLOCAL_RULES: bool = false;
    pub fn version() -> Option<&'static str> {
        Some("5.0.0")
    }
    pub fn include_systems() -> &'static [&'static str] {
        &["http://hl7.org/fhir/contributor-summary-style"]
    }
    pub fn include_value_sets() -> &'static [&'static str] {
        &[]
    }
    /// Systems that are included as whole CodeSystems but are not locally enumerable.
    ///
    /// If this is non-empty, callers should use a terminology server for definitive validation.
    pub fn include_whole_systems() -> &'static [&'static str] {
        &[]
    }
    /// Returns true only when this ValueSet can be treated as fully locally checkable.
    ///
    /// If `HAS_NONLOCAL_RULES` is true (filters, include.valueSet, or non-enumerated whole-system includes),
    /// local checks are best-effort and may require a terminology server.
    pub fn is_locally_enumerated() -> bool {
        !Self::HAS_NONLOCAL_RULES
            && (!Self::expansion_pairs().is_empty() || !Self::include_pairs().is_empty())
    }
    fn include_pairs() -> &'static [(&'static str, &'static str)] {
        &[
            ("http://hl7.org/fhir/contributor-summary-style", "a1full"),
            ("http://hl7.org/fhir/contributor-summary-style", "a1init"),
            ("http://hl7.org/fhir/contributor-summary-style", "a3full"),
            ("http://hl7.org/fhir/contributor-summary-style", "a3init"),
            ("http://hl7.org/fhir/contributor-summary-style", "a6full"),
            ("http://hl7.org/fhir/contributor-summary-style", "a6init"),
            ("http://hl7.org/fhir/contributor-summary-style", "aallfull"),
            ("http://hl7.org/fhir/contributor-summary-style", "aallfullwithand"),
            ("http://hl7.org/fhir/contributor-summary-style", "aallfullwithampersand"),
            ("http://hl7.org/fhir/contributor-summary-style", "aallinit"),
            ("http://hl7.org/fhir/contributor-summary-style", "aallinitwithand"),
            ("http://hl7.org/fhir/contributor-summary-style", "aallinitwithampersand"),
            ("http://hl7.org/fhir/contributor-summary-style", "contr-full-by-person"),
            ("http://hl7.org/fhir/contributor-summary-style", "contr-init-by-person"),
            ("http://hl7.org/fhir/contributor-summary-style", "contr-full-by-contr"),
            ("http://hl7.org/fhir/contributor-summary-style", "contr-init-by-contr"),
        ]
    }
    fn include_entries() -> &'static [(
        &'static str,
        &'static str,
        Option<&'static str>,
        Option<&'static str>,
    )] {
        &[
            (
                "http://hl7.org/fhir/contributor-summary-style",
                "a1full",
                Some("First author (full name) et al"),
                Some("Example: Jennifer Laskowski et al."),
            ),
            (
                "http://hl7.org/fhir/contributor-summary-style",
                "a1init",
                Some("First author (last name first initials) et al"),
                Some("Example: Laskowski J et al."),
            ),
            (
                "http://hl7.org/fhir/contributor-summary-style",
                "a3full",
                Some("First 3 authors (full name) et al"),
                Some(
                    "Example: Jennifer Laskowski, Brandon Renner, Matthew C. Pickering, et al.",
                ),
            ),
            (
                "http://hl7.org/fhir/contributor-summary-style",
                "a3init",
                Some("First 3 authors (last name first initials) et al"),
                Some("Example:  Laskowski J, Renner B, Pickering MC, et al."),
            ),
            (
                "http://hl7.org/fhir/contributor-summary-style",
                "a6full",
                Some("First 6 authors (full name) et al"),
                Some(
                    "Example: Jennifer Laskowski, Brandon Renner, Matthew C. Pickering, Natalie J. Serkova, Peter M. Smith-Jones, Eric T. Clambey, et al.",
                ),
            ),
            (
                "http://hl7.org/fhir/contributor-summary-style",
                "a6init",
                Some("First 6 authors (last name first initials) et al"),
                Some(
                    "Example: Laskowski J, Renner B, Pickering MC, Serkova NJ, Smith-Jones PM, Clambey ET, et al.",
                ),
            ),
            (
                "http://hl7.org/fhir/contributor-summary-style",
                "aallfull",
                Some("All authors (full name)"),
                Some(
                    "Example: Jennifer Laskowski, Brandon Renner, Matthew C. Pickering, Natalie J. Serkova, Peter M. Smith-Jones, Eric T. Clambey, Raphael A. Nemenoff, Joshua M. Thurman.",
                ),
            ),
            (
                "http://hl7.org/fhir/contributor-summary-style",
                "aallfullwithampersand",
                Some("All authors (full name) with an ampersand before last author"),
                Some(
                    "Example: Jennifer Laskowski, Brandon Renner, Matthew C. Pickering, Natalie J. Serkova, Peter M. Smith-Jones, Eric T. Clambey, Raphael A. Nemenoff, & Joshua M. Thurman.",
                ),
            ),
            (
                "http://hl7.org/fhir/contributor-summary-style",
                "aallfullwithand",
                Some("All authors (full name) with and before last author"),
                Some(
                    "Example: Jennifer Laskowski, Brandon Renner, Matthew C. Pickering, Natalie J. Serkova, Peter M. Smith-Jones, Eric T. Clambey, Raphael A. Nemenoff, and Joshua M. Thurman.",
                ),
            ),
            (
                "http://hl7.org/fhir/contributor-summary-style",
                "aallinit",
                Some("All authors (last name first initials)"),
                Some(
                    "Example: Laskowski J, Renner B, Pickering MC, Serkova NJ, Smith-Jones PM, Clambey ET, Nemenoff RA, Thurman JM.",
                ),
            ),
            (
                "http://hl7.org/fhir/contributor-summary-style",
                "aallinitwithampersand",
                Some(
                    "All authors (last name first initials) with an ampersand before last author",
                ),
                Some(
                    "Example: Laskowski J, Renner B, Pickering MC, Serkova NJ, Smith-Jones PM, Clambey ET, Nemenoff RA, & Thurman JM.",
                ),
            ),
            (
                "http://hl7.org/fhir/contributor-summary-style",
                "aallinitwithand",
                Some(
                    "All authors (last name first initials) with and before last author",
                ),
                Some(
                    "Example: Laskowski J, Renner B, Pickering MC, Serkova NJ, Smith-Jones PM, Clambey ET, Nemenoff RA, and Thurman JM.",
                ),
            ),
            (
                "http://hl7.org/fhir/contributor-summary-style",
                "contr-full-by-contr",
                Some("Contributorship statement listed by contribution with full names"),
                Some(
                    "Project design by Jennnifer Laskowski (JL), Experiment design by JL and Joshua M. Thurman (JMT), technical advice and study design contribution by Matthew C. Pickering, experiments performed by JL, data collection and analysis by JL, PET imaging and associated analyses by Natalie J. Serkova and Peter M. Smith-Jones, conceptual and technical guidance by Eric T. Clambey (etc.) and Raphael A. Nemenoff (RAN), manuscript writing by JL and JMT, manuscript revised critically by JL, Brandon Renner, etc., and RAN.",
                ),
            ),
            (
                "http://hl7.org/fhir/contributor-summary-style",
                "contr-full-by-person",
                Some("Contributorship statement listed by person with full names"),
                Some(
                    "Jennnifer Laskowski designed project; developed and performed experiments; collected and analyzed data; wrote and revised manuscript. Brandon Renner performed critical review of manuscript. Matthew C. Pickering provided technical advice and contributed to study design. Natalie J. Serkova and Peter M. Smith-Jones performed PET imaging and associated analyses. Eric T. Clambey and Raphael A. Nemenoff provided conceptual and technical guidance and critical review of manuscript. Joshua M. Thurman contributed to experimental design and wrote manuscript.",
                ),
            ),
            (
                "http://hl7.org/fhir/contributor-summary-style",
                "contr-init-by-contr",
                Some("Contributorship statement listed by contribution with initials"),
                Some(
                    "Project design by JL, Experiment design by JL and JMT, technical advice and study design contribution by MCP, experiments performed by JL, data collection and analysis by JL, PET imaging and associated analyses by NJS and PMS-J, conceptual and technical guidance by etc. and RAN, manuscript writing by JL and JMT, manuscript revised critically by JL, BR, etc., and RAN.",
                ),
            ),
            (
                "http://hl7.org/fhir/contributor-summary-style",
                "contr-init-by-person",
                Some("Contributorship statement listed by person with initials"),
                Some(
                    "J.L. designed project; developed and performed experiments; collected and analyzed data; wrote and revised manuscript. B.R. performed critical review of manuscript. M.C.P. provided technical advice and contributed to study design. N.J.S and P.M.S.-J. performed PET imaging and associated analyses. E.T.C. and R.A.N provided conceptual and technical guidance and critical review of manuscript. J.M.T contributed to experimental design and wrote manuscript.",
                ),
            ),
        ]
    }
    /// Return the preferred display text for a (system, code) pair, if present in this ValueSet's explicit concepts.
    pub fn display(system: &str, code: &str) -> Option<&'static str> {
        for (s, c, d, _def) in Self::include_entries() {
            if *s == system && *c == code {
                return *d;
            }
        }
        None
    }
    /// Return the ValueSet concept definition for a (system, code) pair, if present.
    ///
    /// In `valuesets.json` this often comes from the extension:
    /// `http://hl7.org/fhir/StructureDefinition/valueset-concept-definition`.
    pub fn definition(system: &str, code: &str) -> Option<&'static str> {
        for (s, c, _d, def) in Self::include_entries() {
            if *s == system && *c == code {
                return *def;
            }
        }
        None
    }
    /// Create a minimal `Coding` from a (system, code) pair.
    ///
    /// If this ValueSet provides an explicit display for the code, it will be populated.
    pub fn to_coding(system: &str, code: &str) -> Coding {
        let sys_uri: Uri = Element {
            id: None,
            extension: None,
            value: Some(system.to_string()),
        };
        let code_el: Code = Element {
            id: None,
            extension: None,
            value: Some(code.to_string()),
        };
        let display = Self::display(system, code)
            .map(|s| FhirString {
                id: None,
                extension: None,
                value: Some(s.to_string()),
            });
        Coding {
            id: None,
            extension: None,
            system: Some(sys_uri),
            version: Self::version()
                .map(|v| FhirString {
                    id: None,
                    extension: None,
                    value: Some(v.to_string()),
                }),
            code: Some(code_el),
            display,
            user_selected: None,
        }
    }
    fn exclude_pairs() -> &'static [(&'static str, &'static str)] {
        &[]
    }
    fn expansion_pairs() -> &'static [(&'static str, &'static str)] {
        &[]
    }
    /// Best-effort local validation for a `Coding` against this ValueSet.
    ///
    /// Rules:
    /// - Explicit excludes (compose.exclude.concept) always deny.
    /// - If expansion.contains exists, it is treated as an explicit allow-list.
    /// - Else if compose.include.concept exists, it is treated as an explicit allow-list.
    /// - Else: fall back to whole-system validation when possible (generated CodeSystem enums / RGB grammar).
    ///
    /// Note: terminology filters and include.valueSet references are NOT evaluated locally.
    pub fn contains_coding(coding: &Coding) -> bool {
        let system = match &coding.system {
            Some(s) => s.value.as_deref().unwrap_or(""),
            None => return false,
        };
        let code = match &coding.code {
            Some(c) => c.value.as_deref().unwrap_or(""),
            None => return false,
        };
        if Self::exclude_pairs().iter().any(|(s, c)| *s == system && *c == code) {
            return false;
        }
        let exp = Self::expansion_pairs();
        if !exp.is_empty() {
            return exp.iter().any(|(s, c)| *s == system && *c == code);
        }
        let inc = Self::include_pairs();
        if !inc.is_empty() {
            return inc.iter().any(|(s, c)| *s == system && *c == code);
        }
        match system {
            "http://hl7.org/fhir/contributor-summary-style" => {
                super::super::code_systems::contributor_summary_style::ContributorSummaryStyle::try_from_code(
                        code,
                    )
                    .is_ok()
            }
            _ => false,
        }
    }
    /// Best-effort local validation for a `CodeableConcept` against this ValueSet.
    ///
    /// Returns true if any `coding` entry is contained in the ValueSet.
    pub fn contains_codeable_concept(cc: &CodeableConcept) -> bool {
        match cc.coding.as_ref() {
            Some(codings) => codings.iter().any(|c| Self::contains_coding(c)),
            None => false,
        }
    }
    /// Convenience: validate a FHIR `code` primitive when the binding is on `code`.
    ///
    /// This only works reliably when the ValueSet includes exactly one system.
    pub fn contains_code(code: &Code) -> bool {
        let code_str = match code.value.as_deref() {
            Some(v) => v,
            None => return false,
        };
        let systems = Self::include_systems();
        if systems.len() != 1 {
            return false;
        }
        let system: Uri = Element {
            id: None,
            extension: None,
            value: Some(systems[0].to_string()),
        };
        let code: Code = Element {
            id: None,
            extension: None,
            value: Some(code_str.to_string()),
        };
        let coding = Coding {
            id: None,
            extension: None,
            system: Some(system),
            version: None,
            code: Some(code),
            display: None,
            user_selected: None,
        };
        Self::contains_coding(&coding)
    }
    /// Create a minimal `CodeableConcept` (single coding) from a (system, code) pair.
    pub fn to_codeable_concept(system: &str, code: &str) -> CodeableConcept {
        let coding = Self::to_coding(system, code);
        CodeableConcept {
            id: None,
            extension: None,
            coding: Some(vec![coding]),
            text: None,
        }
    }
}
impl super::super::bindings::ValueSetMembership<Code> for ContributorSummaryStyle {
    fn contains(v: &Code) -> bool {
        Self::contains_code(v)
    }
}
impl super::super::bindings::ValueSetMembership<Coding> for ContributorSummaryStyle {
    fn contains(v: &Coding) -> bool {
        Self::contains_coding(v)
    }
}
impl super::super::bindings::ValueSetMembership<CodeableConcept>
for ContributorSummaryStyle {
    fn contains(v: &CodeableConcept) -> bool {
        Self::contains_codeable_concept(v)
    }
}
fn is_rgb_hex(code: &str) -> bool {
    let b = code.as_bytes();
    if b.len() != 7 || b[0] != b'#' {
        return false;
    }
    fn is_hex(x: u8) -> bool {
        (b'0'..=b'9').contains(&x) || (b'a'..=b'f').contains(&x)
            || (b'A'..=b'F').contains(&x)
    }
    is_hex(b[1]) && is_hex(b[2]) && is_hex(b[3]) && is_hex(b[4]) && is_hex(b[5])
        && is_hex(b[6])
}

