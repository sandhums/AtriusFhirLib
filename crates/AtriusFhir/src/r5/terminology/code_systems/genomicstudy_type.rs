// @generated by AtriusValueSetGen
// DO NOT EDIT MANUALLY

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(clippy::upper_case_acronyms)]

use serde::{Deserialize, Serialize};

use super::super::super::{Boolean, Code, CodeableConcept, Coding, Element, Uri};

use super::super::super::string::String as FhirString;

///FHIR CodeSystem: GenomicStudyType
///Canonical URL: http://hl7.org/fhir/genomicstudy-type
///Version: 5.0.0
///Title: Genomic Study Type
///Status: active
///The type relevant to GenomicStudy.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum GenomicStudyType {
    ///Display: Alternative splicing detection
    ///Definition: Identification of multiple different processed mRNA transcripts from the same DNA template
    #[serde(rename = "alt-splc")]
    AltSplc,
    ///Display: Chromatin conformation
    ///Definition: Analysis of the spacial organization of chromatin within a cell
    #[serde(rename = "chromatin")]
    Chromatin,
    ///Display: CNV detection
    ///Definition: Detection of a change in the number of copies of a defined region of genomic DNA sequence resulting in structural variation when compared to the reference sequence
    #[serde(rename = "cnv")]
    Cnv,
    ///Display: Epigenetic Alterations - histone modifications
    ///Definition: Detection of biochemical modifications covalently bound to the N-terminal tail of a histone protein. These modifications may alter chromatin compaction and gene expression
    #[serde(rename = "epi-alt-hist")]
    EpiAltHist,
    ///Display: Epigenetic Alterations -DNA methylation
    ///Definition: Detection of the presence of an additional methyl group on a DNA nucleobase, which may alter gene transcription
    #[serde(rename = "epi-alt-dna")]
    EpiAltDna,
    ///Display: Familial variant segregation
    ///Definition: Determining if a variant identified in an individual is present in other family members
    #[serde(rename = "fam-var-segr")]
    FamVarSegr,
    ///Display: Functional variation detection
    ///Definition: Detection of sequence variants which may alter gene expression or gene product function when compared to the reference sequence
    #[serde(rename = "func-var")]
    FuncVar,
    ///Display: Gene expression profiling
    ///Definition: Measurement and characterization of activity from all gene products
    #[serde(rename = "gene-expression")]
    GeneExpression,
    ///Display: Post-translational Modification Identification
    ///Definition: Detection of biochemical modifications covalently bound to the amino acid monomers of a processed protein
    #[serde(rename = "post-trans-mod")]
    PostTransMod,
    ///Display: SNP Detection
    ///Definition: Determination of which nucleotide is base present at a known variable location of the genomic sequence
    #[serde(rename = "snp")]
    Snp,
    ///Display: STR count
    ///Definition: Quantification of the number of sequential microsatellite units in a repetitive sequence region
    #[serde(rename = "str")]
    Str,
    ///Display: Structural variation detection
    ///Definition: Detection of deletions, insertions, or rearrangements of DNA segments compared to the reference sequence
    #[serde(rename = "struc-var")]
    StrucVar,
}
impl GenomicStudyType {
    pub fn as_code(&self) -> &'static str {
        match self {
            GenomicStudyType::AltSplc => "alt-splc",
            GenomicStudyType::Chromatin => "chromatin",
            GenomicStudyType::Cnv => "cnv",
            GenomicStudyType::EpiAltHist => "epi-alt-hist",
            GenomicStudyType::EpiAltDna => "epi-alt-dna",
            GenomicStudyType::FamVarSegr => "fam-var-segr",
            GenomicStudyType::FuncVar => "func-var",
            GenomicStudyType::GeneExpression => "gene-expression",
            GenomicStudyType::PostTransMod => "post-trans-mod",
            GenomicStudyType::Snp => "snp",
            GenomicStudyType::Str => "str",
            GenomicStudyType::StrucVar => "struc-var",
        }
    }
    pub fn system() -> &'static str {
        "http://hl7.org/fhir/genomicstudy-type"
    }
    pub fn version() -> Option<&'static str> {
        Some("5.0.0")
    }
    /// Convert this code into a FHIR `code` primitive (`Code = Element<String, Extension>`).
    ///
    /// Useful for elements like `Patient.gender` that are bound directly to a ValueSet and use
    /// the `code` datatype.
    pub fn to_code(self) -> Code {
        Element {
            id: None,
            extension: None,
            value: Some(self.as_code().to_string()),
        }
    }
    /// Convert this code into a FHIR `Coding` with `system` and (if available) `version` set.
    ///
    /// Useful for `Coding` fields and for inclusion inside `CodeableConcept.coding`.
    pub fn to_coding(self) -> Coding {
        let system: Uri = Element {
            id: None,
            extension: None,
            value: Some(Self::system().to_string()),
        };
        Coding {
            id: None,
            extension: None,
            system: Some(system),
            version: Self::version()
                .map(|v| FhirString {
                    id: None,
                    extension: None,
                    value: Some(v.to_string()),
                }),
            code: Some(self.to_code()),
            display: None,
            user_selected: Option::<Boolean>::None,
        }
    }
    /// Convert this code into a minimal `CodeableConcept` (with a single `coding`).
    ///
    /// This is especially useful for bound elements that use `CodeableConcept` (e.g.
    /// extensible bindings).
    pub fn to_codeable_concept(self) -> CodeableConcept {
        CodeableConcept {
            id: None,
            extension: None,
            coding: Some(vec![self.to_coding()]),
            text: None,
        }
    }
    /// Parse a code string into this enum.
    ///
    /// This is a convenience wrapper around the `TryFrom<&str>` implementation.
    pub fn try_from_code(code: &str) -> Result<Self, ()> {
        <Self as core::convert::TryFrom<&str>>::try_from(code)
    }
    /// Parse from a FHIR `code` primitive (`Code = Element<String, Extension>`).
    pub fn try_from_code_element(code: &Code) -> Result<Self, ()> {
        match code.value.as_deref() {
            Some(v) => Self::try_from_code(v),
            None => Err(()),
        }
    }
}
impl core::convert::TryFrom<&str> for GenomicStudyType {
    type Error = ();
    fn try_from(s: &str) -> Result<Self, <Self as core::convert::TryFrom<&str>>::Error> {
        match s {
            "alt-splc" => Ok(GenomicStudyType::AltSplc),
            "chromatin" => Ok(GenomicStudyType::Chromatin),
            "cnv" => Ok(GenomicStudyType::Cnv),
            "epi-alt-hist" => Ok(GenomicStudyType::EpiAltHist),
            "epi-alt-dna" => Ok(GenomicStudyType::EpiAltDna),
            "fam-var-segr" => Ok(GenomicStudyType::FamVarSegr),
            "func-var" => Ok(GenomicStudyType::FuncVar),
            "gene-expression" => Ok(GenomicStudyType::GeneExpression),
            "post-trans-mod" => Ok(GenomicStudyType::PostTransMod),
            "snp" => Ok(GenomicStudyType::Snp),
            "str" => Ok(GenomicStudyType::Str),
            "struc-var" => Ok(GenomicStudyType::StrucVar),
            _ => Err(()),
        }
    }
}
impl core::fmt::Display for GenomicStudyType {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(self.as_code())
    }
}

