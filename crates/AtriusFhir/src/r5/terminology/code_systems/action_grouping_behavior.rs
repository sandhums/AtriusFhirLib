// @generated by AtriusValueSetGen
// DO NOT EDIT MANUALLY

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(clippy::upper_case_acronyms)]

use serde::{Deserialize, Serialize};

use super::super::super::{Boolean, Code, CodeableConcept, Coding, Element, Uri};

use super::super::super::string::String as FhirString;

///FHIR CodeSystem: ActionGroupingBehavior
///Canonical URL: http://hl7.org/fhir/action-grouping-behavior
///Version: 5.0.0
///Title: Action Grouping Behavior
///Status: active
///Defines organization behavior of a group.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ActionGroupingBehavior {
    ///Display: Visual Group
    ///Definition: Any group marked with this behavior should be displayed as a visual group to the end user.
    #[serde(rename = "visual-group")]
    VisualGroup,
    ///Display: Logical Group
    ///Definition: A group with this behavior logically groups its sub-elements, and may be shown as a visual group to the end user, but it is not required to do so.
    #[serde(rename = "logical-group")]
    LogicalGroup,
    ///Display: Sentence Group
    ///Definition: A group of related alternative actions is a sentence group if the target referenced by the action is the same in all the actions and each action simply constitutes a different variation on how to specify the details for the target. For example, two actions that could be in a SentenceGroup are "aspirin, 500 mg, 2 times per day" and "aspirin, 300 mg, 3 times per day". In both cases, aspirin is the target referenced by the action, and the two actions represent different options for how aspirin might be ordered for the patient. Note that a SentenceGroup would almost always have an associated selection behavior of "AtMostOne", unless it's a required action, in which case, it would be "ExactlyOne".
    #[serde(rename = "sentence-group")]
    SentenceGroup,
}
impl ActionGroupingBehavior {
    pub fn as_code(&self) -> &'static str {
        match self {
            ActionGroupingBehavior::VisualGroup => "visual-group",
            ActionGroupingBehavior::LogicalGroup => "logical-group",
            ActionGroupingBehavior::SentenceGroup => "sentence-group",
        }
    }
    pub fn system() -> &'static str {
        "http://hl7.org/fhir/action-grouping-behavior"
    }
    pub fn version() -> Option<&'static str> {
        Some("5.0.0")
    }
    /// Convert this code into a FHIR `code` primitive (`Code = Element<String, Extension>`).
    ///
    /// Useful for elements like `Patient.gender` that are bound directly to a ValueSet and use
    /// the `code` datatype.
    pub fn to_code(self) -> Code {
        Element {
            id: None,
            extension: None,
            value: Some(self.as_code().to_string()),
        }
    }
    /// Convert this code into a FHIR `Coding` with `system` and (if available) `version` set.
    ///
    /// Useful for `Coding` fields and for inclusion inside `CodeableConcept.coding`.
    pub fn to_coding(self) -> Coding {
        let system: Uri = Element {
            id: None,
            extension: None,
            value: Some(Self::system().to_string()),
        };
        Coding {
            id: None,
            extension: None,
            system: Some(system),
            version: Self::version()
                .map(|v| FhirString {
                    id: None,
                    extension: None,
                    value: Some(v.to_string()),
                }),
            code: Some(self.to_code()),
            display: None,
            user_selected: Option::<Boolean>::None,
        }
    }
    /// Convert this code into a minimal `CodeableConcept` (with a single `coding`).
    ///
    /// This is especially useful for bound elements that use `CodeableConcept` (e.g.
    /// extensible bindings).
    pub fn to_codeable_concept(self) -> CodeableConcept {
        CodeableConcept {
            id: None,
            extension: None,
            coding: Some(vec![self.to_coding()]),
            text: None,
        }
    }
    /// Parse a code string into this enum.
    ///
    /// This is a convenience wrapper around the `TryFrom<&str>` implementation.
    pub fn try_from_code(code: &str) -> Result<Self, ()> {
        <Self as core::convert::TryFrom<&str>>::try_from(code)
    }
    /// Parse from a FHIR `code` primitive (`Code = Element<String, Extension>`).
    pub fn try_from_code_element(code: &Code) -> Result<Self, ()> {
        match code.value.as_deref() {
            Some(v) => Self::try_from_code(v),
            None => Err(()),
        }
    }
}
impl core::convert::TryFrom<&str> for ActionGroupingBehavior {
    type Error = ();
    fn try_from(s: &str) -> Result<Self, <Self as core::convert::TryFrom<&str>>::Error> {
        match s {
            "visual-group" => Ok(ActionGroupingBehavior::VisualGroup),
            "logical-group" => Ok(ActionGroupingBehavior::LogicalGroup),
            "sentence-group" => Ok(ActionGroupingBehavior::SentenceGroup),
            _ => Err(()),
        }
    }
}
impl core::fmt::Display for ActionGroupingBehavior {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(self.as_code())
    }
}

