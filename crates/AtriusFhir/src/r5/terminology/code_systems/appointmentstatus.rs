// @generated by AtriusValueSetGen
// DO NOT EDIT MANUALLY

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(clippy::upper_case_acronyms)]

use serde::{Deserialize, Serialize};

use super::super::super::{Boolean, Code, CodeableConcept, Coding, Element, Uri};

use super::super::super::string::String as FhirString;

///FHIR CodeSystem: AppointmentStatus
///Canonical URL: http://hl7.org/fhir/appointmentstatus
///Version: 5.0.0
///Title: Appointment Status
///Status: active
///The free/busy status of an appointment.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum AppointmentStatus {
    ///Display: Proposed
    ///Definition: None of the participant(s) have finalized their acceptance of the appointment request, and the start/end time might not be set yet.
    #[serde(rename = "proposed")]
    Proposed,
    ///Display: Pending
    ///Definition: Some or all of the participant(s) have not finalized their acceptance of the appointment request.
    #[serde(rename = "pending")]
    Pending,
    ///Display: Booked
    ///Definition: All participant(s) have been considered and the appointment is confirmed to go ahead at the date/times specified.
    #[serde(rename = "booked")]
    Booked,
    ///Display: Arrived
    ///Definition: The patient/patients has/have arrived and is/are waiting to be seen.
    #[serde(rename = "arrived")]
    Arrived,
    ///Display: Fulfilled
    ///Definition: The planning stages of the appointment are now complete, the encounter resource will exist and will track further status changes. Note that an encounter may exist before the appointment status is fulfilled for many reasons.
    #[serde(rename = "fulfilled")]
    Fulfilled,
    ///Display: Cancelled
    ///Definition: The appointment has been cancelled.
    #[serde(rename = "cancelled")]
    Cancelled,
    ///Display: No Show
    ///Definition: Some or all of the participant(s) have not/did not appear for the appointment (usually the patient).
    #[serde(rename = "noshow")]
    Noshow,
    ///Display: Entered in error
    ///Definition: This instance should not have been part of this patient's medical record.
    #[serde(rename = "entered-in-error")]
    EnteredInError,
    ///Display: Checked In
    ///Definition: When checked in, all pre-encounter administrative work is complete, and the encounter may begin. (where multiple patients are involved, they are all present).
    #[serde(rename = "checked-in")]
    CheckedIn,
    ///Display: Waitlisted
    ///Definition: The appointment has been placed on a waitlist, to be scheduled/confirmed in the future when a slot/service is available.
    ///A specific time might or might not be pre-allocated.
    #[serde(rename = "waitlist")]
    Waitlist,
}
impl AppointmentStatus {
    pub fn as_code(&self) -> &'static str {
        match self {
            AppointmentStatus::Proposed => "proposed",
            AppointmentStatus::Pending => "pending",
            AppointmentStatus::Booked => "booked",
            AppointmentStatus::Arrived => "arrived",
            AppointmentStatus::Fulfilled => "fulfilled",
            AppointmentStatus::Cancelled => "cancelled",
            AppointmentStatus::Noshow => "noshow",
            AppointmentStatus::EnteredInError => "entered-in-error",
            AppointmentStatus::CheckedIn => "checked-in",
            AppointmentStatus::Waitlist => "waitlist",
        }
    }
    pub fn system() -> &'static str {
        "http://hl7.org/fhir/appointmentstatus"
    }
    pub fn version() -> Option<&'static str> {
        Some("5.0.0")
    }
    /// Convert this code into a FHIR `code` primitive (`Code = Element<String, Extension>`).
    ///
    /// Useful for elements like `Patient.gender` that are bound directly to a ValueSet and use
    /// the `code` datatype.
    pub fn to_code(self) -> Code {
        Element {
            id: None,
            extension: None,
            value: Some(self.as_code().to_string()),
        }
    }
    /// Convert this code into a FHIR `Coding` with `system` and (if available) `version` set.
    ///
    /// Useful for `Coding` fields and for inclusion inside `CodeableConcept.coding`.
    pub fn to_coding(self) -> Coding {
        let system: Uri = Element {
            id: None,
            extension: None,
            value: Some(Self::system().to_string()),
        };
        Coding {
            id: None,
            extension: None,
            system: Some(system),
            version: Self::version()
                .map(|v| FhirString {
                    id: None,
                    extension: None,
                    value: Some(v.to_string()),
                }),
            code: Some(self.to_code()),
            display: None,
            user_selected: Option::<Boolean>::None,
        }
    }
    /// Convert this code into a minimal `CodeableConcept` (with a single `coding`).
    ///
    /// This is especially useful for bound elements that use `CodeableConcept` (e.g.
    /// extensible bindings).
    pub fn to_codeable_concept(self) -> CodeableConcept {
        CodeableConcept {
            id: None,
            extension: None,
            coding: Some(vec![self.to_coding()]),
            text: None,
        }
    }
    /// Parse a code string into this enum.
    ///
    /// This is a convenience wrapper around the `TryFrom<&str>` implementation.
    pub fn try_from_code(code: &str) -> Result<Self, ()> {
        <Self as core::convert::TryFrom<&str>>::try_from(code)
    }
    /// Parse from a FHIR `code` primitive (`Code = Element<String, Extension>`).
    pub fn try_from_code_element(code: &Code) -> Result<Self, ()> {
        match code.value.as_deref() {
            Some(v) => Self::try_from_code(v),
            None => Err(()),
        }
    }
}
impl core::convert::TryFrom<&str> for AppointmentStatus {
    type Error = ();
    fn try_from(s: &str) -> Result<Self, <Self as core::convert::TryFrom<&str>>::Error> {
        match s {
            "proposed" => Ok(AppointmentStatus::Proposed),
            "pending" => Ok(AppointmentStatus::Pending),
            "booked" => Ok(AppointmentStatus::Booked),
            "arrived" => Ok(AppointmentStatus::Arrived),
            "fulfilled" => Ok(AppointmentStatus::Fulfilled),
            "cancelled" => Ok(AppointmentStatus::Cancelled),
            "noshow" => Ok(AppointmentStatus::Noshow),
            "entered-in-error" => Ok(AppointmentStatus::EnteredInError),
            "checked-in" => Ok(AppointmentStatus::CheckedIn),
            "waitlist" => Ok(AppointmentStatus::Waitlist),
            _ => Err(()),
        }
    }
}
impl core::fmt::Display for AppointmentStatus {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(self.as_code())
    }
}

