// @generated by AtriusValueSetGen
// DO NOT EDIT MANUALLY

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(clippy::upper_case_acronyms)]

use serde::{Deserialize, Serialize};

use super::super::super::{Boolean, Code, CodeableConcept, Coding, Element, Uri};

use super::super::super::string::String as FhirString;

///FHIR CodeSystem: StructureDefinitionKind
///Canonical URL: http://hl7.org/fhir/structure-definition-kind
///Version: 5.0.0
///Title: Structure Definition Kind
///Status: active
///Defines the type of structure that a definition is describing.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum StructureDefinitionKind {
    ///Display: Primitive Data Type
    ///Definition: A primitive type that has a value and an extension. These can be used throughout complex datatype, Resource and extension definitions. Only the base specification can define primitive types.
    #[serde(rename = "primitive-type")]
    PrimitiveType,
    ///Display: Complex Data Type
    ///Definition: A  complex structure that defines a set of data elements that is suitable for use in 'resources'. The base specification defines a number of complex types, and other specifications can define additional types. These structures do not have a maintained identity.
    #[serde(rename = "complex-type")]
    ComplexType,
    ///Display: Resource
    ///Definition: A 'resource' - a directed acyclic graph of elements that aggregrates other types into an identifiable entity. The base FHIR resources are defined by the FHIR specification itself but other 'resources' can be defined in additional specifications (though these will not be recognized as 'resources' by the FHIR specification; i.e. they do not get end-points etc., or act as the targets of references in FHIR defined resources - though other specifications can treat them this way).
    #[serde(rename = "resource")]
    Resource,
    ///Display: Logical
    ///Definition: A pattern or a template that is not intended to be a real resource or complex type.
    #[serde(rename = "logical")]
    Logical,
}
impl StructureDefinitionKind {
    pub fn as_code(&self) -> &'static str {
        match self {
            StructureDefinitionKind::PrimitiveType => "primitive-type",
            StructureDefinitionKind::ComplexType => "complex-type",
            StructureDefinitionKind::Resource => "resource",
            StructureDefinitionKind::Logical => "logical",
        }
    }
    pub fn system() -> &'static str {
        "http://hl7.org/fhir/structure-definition-kind"
    }
    pub fn version() -> Option<&'static str> {
        Some("5.0.0")
    }
    /// Convert this code into a FHIR `code` primitive (`Code = Element<String, Extension>`).
    ///
    /// Useful for elements like `Patient.gender` that are bound directly to a ValueSet and use
    /// the `code` datatype.
    pub fn to_code(self) -> Code {
        Element {
            id: None,
            extension: None,
            value: Some(self.as_code().to_string()),
        }
    }
    /// Convert this code into a FHIR `Coding` with `system` and (if available) `version` set.
    ///
    /// Useful for `Coding` fields and for inclusion inside `CodeableConcept.coding`.
    pub fn to_coding(self) -> Coding {
        let system: Uri = Element {
            id: None,
            extension: None,
            value: Some(Self::system().to_string()),
        };
        Coding {
            id: None,
            extension: None,
            system: Some(system),
            version: Self::version()
                .map(|v| FhirString {
                    id: None,
                    extension: None,
                    value: Some(v.to_string()),
                }),
            code: Some(self.to_code()),
            display: None,
            user_selected: Option::<Boolean>::None,
        }
    }
    /// Convert this code into a minimal `CodeableConcept` (with a single `coding`).
    ///
    /// This is especially useful for bound elements that use `CodeableConcept` (e.g.
    /// extensible bindings).
    pub fn to_codeable_concept(self) -> CodeableConcept {
        CodeableConcept {
            id: None,
            extension: None,
            coding: Some(vec![self.to_coding()]),
            text: None,
        }
    }
    /// Parse a code string into this enum.
    ///
    /// This is a convenience wrapper around the `TryFrom<&str>` implementation.
    pub fn try_from_code(code: &str) -> Result<Self, ()> {
        <Self as core::convert::TryFrom<&str>>::try_from(code)
    }
    /// Parse from a FHIR `code` primitive (`Code = Element<String, Extension>`).
    pub fn try_from_code_element(code: &Code) -> Result<Self, ()> {
        match code.value.as_deref() {
            Some(v) => Self::try_from_code(v),
            None => Err(()),
        }
    }
}
impl core::convert::TryFrom<&str> for StructureDefinitionKind {
    type Error = ();
    fn try_from(s: &str) -> Result<Self, <Self as core::convert::TryFrom<&str>>::Error> {
        match s {
            "primitive-type" => Ok(StructureDefinitionKind::PrimitiveType),
            "complex-type" => Ok(StructureDefinitionKind::ComplexType),
            "resource" => Ok(StructureDefinitionKind::Resource),
            "logical" => Ok(StructureDefinitionKind::Logical),
            _ => Err(()),
        }
    }
}
impl core::fmt::Display for StructureDefinitionKind {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(self.as_code())
    }
}

