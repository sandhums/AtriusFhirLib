// @generated by AtriusValueSetGen
// DO NOT EDIT MANUALLY

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(clippy::upper_case_acronyms)]

use serde::{Deserialize, Serialize};

use super::super::super::{Boolean, Code, CodeableConcept, Coding, Element, Uri};

use super::super::super::string::String as FhirString;

///FHIR CodeSystem: StructureMapTransform
///Canonical URL: http://hl7.org/fhir/map-transform
///Version: 5.0.0
///Title: Structure Map Transform
///Status: active
///How data is copied/created.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum StructureMapTransform {
    ///Display: create
    ///Definition: create(type : string) - type is passed through to the application on the standard API, and must be known by it.
    #[serde(rename = "create")]
    Create,
    ///Display: copy
    ///Definition: copy(source).
    #[serde(rename = "copy")]
    Copy,
    ///Display: truncate
    ///Definition: truncate(source, length) - source must be stringy type.
    #[serde(rename = "truncate")]
    Truncate,
    ///Display: escape
    ///Definition: escape(source, fmt1, fmt2) - change source from one kind of escaping to another (plain, java, xml, json). note that this is for when the string itself is escaped.
    #[serde(rename = "escape")]
    Escape,
    ///Display: cast
    ///Definition: cast(source, type?) - cast (convert) source from one type to another. Target type can be left as implicit if there is one and only one target type known. The default namespace for the type is 'FHIR' (see [FHIRPath type specifiers](http://hl7.org/fhirpath/N1/#is-type-specifier))
    #[serde(rename = "cast")]
    Cast,
    ///Display: append
    ///Definition: append(source...) - source is element or string.
    #[serde(rename = "append")]
    Append,
    ///Display: translate
    ///Definition: translate(source, uri_of_map) - use the translate operation.
    #[serde(rename = "translate")]
    Translate,
    ///Display: reference
    ///Definition: reference(source : object) - return a string that references the provided tree properly.
    #[serde(rename = "reference")]
    Reference,
    ///Display: dateOp
    ///Definition: Perform a date operation. *Parameters to be documented*.
    #[serde(rename = "dateOp")]
    Dateop,
    ///Display: uuid
    ///Definition: Generate a random UUID (in lowercase). No Parameters.
    #[serde(rename = "uuid")]
    Uuid,
    ///Display: pointer
    ///Definition: Return the appropriate string to put in a reference that refers to the resource provided as a parameter.
    #[serde(rename = "pointer")]
    Pointer,
    ///Display: evaluate
    ///Definition: Execute the supplied FHIRPath expression and use the value returned by that.
    #[serde(rename = "evaluate")]
    Evaluate,
    ///Display: cc
    ///Definition: Create a CodeableConcept. Parameters = (text) or (system. Code[, display]).
    #[serde(rename = "cc")]
    Cc,
    ///Display: c
    ///Definition: Create a Coding. Parameters = (system. Code[, display]).
    #[serde(rename = "c")]
    C,
    ///Display: qty
    ///Definition: Create a quantity. Parameters = (text) or (value, unit, [system, code]) where text is the natural representation e.g. [comparator]value[space]unit.
    #[serde(rename = "qty")]
    Qty,
    ///Display: id
    ///Definition: Create an identifier. Parameters = (system, value[, type]) where type is a code from the identifier type value set.
    #[serde(rename = "id")]
    Id,
    ///Display: cp
    ///Definition: Create a contact details. Parameters = (value) or (system, value). If no system is provided, the system should be inferred from the content of the value.
    #[serde(rename = "cp")]
    Cp,
}
impl StructureMapTransform {
    pub fn as_code(&self) -> &'static str {
        match self {
            StructureMapTransform::Create => "create",
            StructureMapTransform::Copy => "copy",
            StructureMapTransform::Truncate => "truncate",
            StructureMapTransform::Escape => "escape",
            StructureMapTransform::Cast => "cast",
            StructureMapTransform::Append => "append",
            StructureMapTransform::Translate => "translate",
            StructureMapTransform::Reference => "reference",
            StructureMapTransform::Dateop => "dateOp",
            StructureMapTransform::Uuid => "uuid",
            StructureMapTransform::Pointer => "pointer",
            StructureMapTransform::Evaluate => "evaluate",
            StructureMapTransform::Cc => "cc",
            StructureMapTransform::C => "c",
            StructureMapTransform::Qty => "qty",
            StructureMapTransform::Id => "id",
            StructureMapTransform::Cp => "cp",
        }
    }
    pub fn system() -> &'static str {
        "http://hl7.org/fhir/map-transform"
    }
    pub fn version() -> Option<&'static str> {
        Some("5.0.0")
    }
    /// Convert this code into a FHIR `code` primitive (`Code = Element<String, Extension>`).
    ///
    /// Useful for elements like `Patient.gender` that are bound directly to a ValueSet and use
    /// the `code` datatype.
    pub fn to_code(self) -> Code {
        Element {
            id: None,
            extension: None,
            value: Some(self.as_code().to_string()),
        }
    }
    /// Convert this code into a FHIR `Coding` with `system` and (if available) `version` set.
    ///
    /// Useful for `Coding` fields and for inclusion inside `CodeableConcept.coding`.
    pub fn to_coding(self) -> Coding {
        let system: Uri = Element {
            id: None,
            extension: None,
            value: Some(Self::system().to_string()),
        };
        Coding {
            id: None,
            extension: None,
            system: Some(system),
            version: Self::version()
                .map(|v| FhirString {
                    id: None,
                    extension: None,
                    value: Some(v.to_string()),
                }),
            code: Some(self.to_code()),
            display: None,
            user_selected: Option::<Boolean>::None,
        }
    }
    /// Convert this code into a minimal `CodeableConcept` (with a single `coding`).
    ///
    /// This is especially useful for bound elements that use `CodeableConcept` (e.g.
    /// extensible bindings).
    pub fn to_codeable_concept(self) -> CodeableConcept {
        CodeableConcept {
            id: None,
            extension: None,
            coding: Some(vec![self.to_coding()]),
            text: None,
        }
    }
    /// Parse a code string into this enum.
    ///
    /// This is a convenience wrapper around the `TryFrom<&str>` implementation.
    pub fn try_from_code(code: &str) -> Result<Self, ()> {
        <Self as core::convert::TryFrom<&str>>::try_from(code)
    }
    /// Parse from a FHIR `code` primitive (`Code = Element<String, Extension>`).
    pub fn try_from_code_element(code: &Code) -> Result<Self, ()> {
        match code.value.as_deref() {
            Some(v) => Self::try_from_code(v),
            None => Err(()),
        }
    }
}
impl core::convert::TryFrom<&str> for StructureMapTransform {
    type Error = ();
    fn try_from(s: &str) -> Result<Self, <Self as core::convert::TryFrom<&str>>::Error> {
        match s {
            "create" => Ok(StructureMapTransform::Create),
            "copy" => Ok(StructureMapTransform::Copy),
            "truncate" => Ok(StructureMapTransform::Truncate),
            "escape" => Ok(StructureMapTransform::Escape),
            "cast" => Ok(StructureMapTransform::Cast),
            "append" => Ok(StructureMapTransform::Append),
            "translate" => Ok(StructureMapTransform::Translate),
            "reference" => Ok(StructureMapTransform::Reference),
            "dateOp" => Ok(StructureMapTransform::Dateop),
            "uuid" => Ok(StructureMapTransform::Uuid),
            "pointer" => Ok(StructureMapTransform::Pointer),
            "evaluate" => Ok(StructureMapTransform::Evaluate),
            "cc" => Ok(StructureMapTransform::Cc),
            "c" => Ok(StructureMapTransform::C),
            "qty" => Ok(StructureMapTransform::Qty),
            "id" => Ok(StructureMapTransform::Id),
            "cp" => Ok(StructureMapTransform::Cp),
            _ => Err(()),
        }
    }
}
impl core::fmt::Display for StructureMapTransform {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(self.as_code())
    }
}

