// @generated by AtriusValueSetGen
// DO NOT EDIT MANUALLY

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(clippy::upper_case_acronyms)]

use serde::{Deserialize, Serialize};

use super::super::super::{Boolean, Code, CodeableConcept, Coding, Element, Uri};

use super::super::super::string::String as FhirString;

///FHIR CodeSystem: AdditionalBindingPurposeCodes
///Canonical URL: http://hl7.org/fhir/CodeSystem/additional-binding-purpose
///Version: 5.0.0
///Title: Additional Binding Purpose Codes
///Status: active
///Additional Binding Purpose
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum AdditionalBindingPurposeCodes {
    ///Display: Maximum Binding
    ///Definition: A required binding, for use when the binding strength is 'extensible' or 'preferred'
    #[serde(rename = "maximum")]
    Maximum,
    ///Display: Minimum Binding
    ///Definition: The minimum allowable value set - any conformant system SHALL support all these codes
    #[serde(rename = "minimum")]
    Minimum,
    ///Display: Required Binding
    ///Definition: This value set is used as a required binding (in addition to the base binding (not a replacement), usually in a particular usage context)
    #[serde(rename = "required")]
    Required,
    ///Display: Conformance Binding
    ///Definition: This value set is used as an extensible binding (in addition to the base binding (not a replacement), usually in a particular usage context)
    #[serde(rename = "extensible")]
    Extensible,
    ///Display: Candidate Binding
    ///Definition: This value set is a candidate to substitute for the overall conformance value set in some situations; usually these are defined in the documentation
    #[serde(rename = "candidate")]
    Candidate,
    ///Display: Current Binding
    ///Definition: New records are required to use this value set, but legacy records may use other codes. The definition of 'new record' is difficult, since systems often create new records based on pre-existing data. Usually 'current' bindings are mandated by an external authority that makes clear rules around this
    #[serde(rename = "current")]
    Current,
    ///Display: Preferred Binding
    ///Definition: This is the value set that is preferred in a given context (documentation should explain why)
    #[serde(rename = "preferred")]
    Preferred,
    ///Display: UI Suggested Binding
    ///Definition: This value set is provided for user look up in a given context. Typically, these valuesets only include a subset of codes relevant for input in a context
    #[serde(rename = "ui")]
    Ui,
    ///Display: Starter Binding
    ///Definition: This value set is a good set of codes to start with when designing your system
    #[serde(rename = "starter")]
    Starter,
    ///Display: Component Binding
    ///Definition: This value set is a component of the base value set. Usually this is called out so that documentation can be written about a portion of the value set
    #[serde(rename = "component")]
    Component,
}
impl AdditionalBindingPurposeCodes {
    pub fn as_code(&self) -> &'static str {
        match self {
            AdditionalBindingPurposeCodes::Maximum => "maximum",
            AdditionalBindingPurposeCodes::Minimum => "minimum",
            AdditionalBindingPurposeCodes::Required => "required",
            AdditionalBindingPurposeCodes::Extensible => "extensible",
            AdditionalBindingPurposeCodes::Candidate => "candidate",
            AdditionalBindingPurposeCodes::Current => "current",
            AdditionalBindingPurposeCodes::Preferred => "preferred",
            AdditionalBindingPurposeCodes::Ui => "ui",
            AdditionalBindingPurposeCodes::Starter => "starter",
            AdditionalBindingPurposeCodes::Component => "component",
        }
    }
    pub fn system() -> &'static str {
        "http://hl7.org/fhir/CodeSystem/additional-binding-purpose"
    }
    pub fn version() -> Option<&'static str> {
        Some("5.0.0")
    }
    /// Convert this code into a FHIR `code` primitive (`Code = Element<String, Extension>`).
    ///
    /// Useful for elements like `Patient.gender` that are bound directly to a ValueSet and use
    /// the `code` datatype.
    pub fn to_code(self) -> Code {
        Element {
            id: None,
            extension: None,
            value: Some(self.as_code().to_string()),
        }
    }
    /// Convert this code into a FHIR `Coding` with `system` and (if available) `version` set.
    ///
    /// Useful for `Coding` fields and for inclusion inside `CodeableConcept.coding`.
    pub fn to_coding(self) -> Coding {
        let system: Uri = Element {
            id: None,
            extension: None,
            value: Some(Self::system().to_string()),
        };
        Coding {
            id: None,
            extension: None,
            system: Some(system),
            version: Self::version()
                .map(|v| FhirString {
                    id: None,
                    extension: None,
                    value: Some(v.to_string()),
                }),
            code: Some(self.to_code()),
            display: None,
            user_selected: Option::<Boolean>::None,
        }
    }
    /// Convert this code into a minimal `CodeableConcept` (with a single `coding`).
    ///
    /// This is especially useful for bound elements that use `CodeableConcept` (e.g.
    /// extensible bindings).
    pub fn to_codeable_concept(self) -> CodeableConcept {
        CodeableConcept {
            id: None,
            extension: None,
            coding: Some(vec![self.to_coding()]),
            text: None,
        }
    }
    /// Parse a code string into this enum.
    ///
    /// This is a convenience wrapper around the `TryFrom<&str>` implementation.
    pub fn try_from_code(code: &str) -> Result<Self, ()> {
        <Self as core::convert::TryFrom<&str>>::try_from(code)
    }
    /// Parse from a FHIR `code` primitive (`Code = Element<String, Extension>`).
    pub fn try_from_code_element(code: &Code) -> Result<Self, ()> {
        match code.value.as_deref() {
            Some(v) => Self::try_from_code(v),
            None => Err(()),
        }
    }
}
impl core::convert::TryFrom<&str> for AdditionalBindingPurposeCodes {
    type Error = ();
    fn try_from(s: &str) -> Result<Self, <Self as core::convert::TryFrom<&str>>::Error> {
        match s {
            "maximum" => Ok(AdditionalBindingPurposeCodes::Maximum),
            "minimum" => Ok(AdditionalBindingPurposeCodes::Minimum),
            "required" => Ok(AdditionalBindingPurposeCodes::Required),
            "extensible" => Ok(AdditionalBindingPurposeCodes::Extensible),
            "candidate" => Ok(AdditionalBindingPurposeCodes::Candidate),
            "current" => Ok(AdditionalBindingPurposeCodes::Current),
            "preferred" => Ok(AdditionalBindingPurposeCodes::Preferred),
            "ui" => Ok(AdditionalBindingPurposeCodes::Ui),
            "starter" => Ok(AdditionalBindingPurposeCodes::Starter),
            "component" => Ok(AdditionalBindingPurposeCodes::Component),
            _ => Err(()),
        }
    }
}
impl core::fmt::Display for AdditionalBindingPurposeCodes {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(self.as_code())
    }
}

