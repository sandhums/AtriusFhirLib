// @generated by AtriusValueSetGen
// DO NOT EDIT MANUALLY

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(clippy::upper_case_acronyms)]

use serde::{Deserialize, Serialize};

use super::super::super::{Boolean, Code, CodeableConcept, Coding, Element, Uri};

use super::super::super::string::String as FhirString;

///FHIR CodeSystem: CitedArtifactClassificationType
///Canonical URL: http://hl7.org/fhir/cited-artifact-classification-type
///Version: 5.0.0
///Title: Cited Artifact Classification Type
///Status: active
///Cited Artifact Classification Type
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum CitedArtifactClassificationType {
    ///Display: Publication type
    ///Definition: Publication type
    #[serde(rename = "publication-type")]
    PublicationType,
    ///Display: MeSH heading
    ///Definition: MeSH heading
    #[serde(rename = "mesh-heading")]
    MeshHeading,
    ///Display: Supplemental MeSH for Protocol
    ///Definition: Supplemental MeSH for Protocol
    #[serde(rename = "supplemental-mesh-protocol")]
    SupplementalMeshProtocol,
    ///Display: Supplemental MeSH for Disease
    ///Definition: Supplemental MeSH for Disease
    #[serde(rename = "supplemental-mesh-disease")]
    SupplementalMeshDisease,
    ///Display: Supplemental MeSH for Organism
    ///Definition: Supplemental MeSH for Organism
    #[serde(rename = "supplemental-mesh-organism")]
    SupplementalMeshOrganism,
    ///Display: Keyword
    ///Definition: Keyword
    #[serde(rename = "keyword")]
    Keyword,
    ///Display: Citation subset
    ///Definition: Citation subset
    #[serde(rename = "citation-subset")]
    CitationSubset,
    ///Display: Chemical
    ///Definition: Chemical
    #[serde(rename = "chemical")]
    Chemical,
    ///Display: Publishing Model
    ///Definition: Used for PubModel attribute in Medline
    #[serde(rename = "publishing-model")]
    PublishingModel,
    ///Display: Knowledge Artifact Type
    ///Definition: Knowledge Artifact Type
    #[serde(rename = "knowledge-artifact-type")]
    KnowledgeArtifactType,
    ///Display: Coverage
    ///Definition: The spatial or temporal topic of the resource, spatial applicability of the resource, or jurisdiction under which the resource is relevant
    #[serde(rename = "coverage")]
    Coverage,
}
impl CitedArtifactClassificationType {
    pub fn as_code(&self) -> &'static str {
        match self {
            CitedArtifactClassificationType::PublicationType => "publication-type",
            CitedArtifactClassificationType::MeshHeading => "mesh-heading",
            CitedArtifactClassificationType::SupplementalMeshProtocol => {
                "supplemental-mesh-protocol"
            }
            CitedArtifactClassificationType::SupplementalMeshDisease => {
                "supplemental-mesh-disease"
            }
            CitedArtifactClassificationType::SupplementalMeshOrganism => {
                "supplemental-mesh-organism"
            }
            CitedArtifactClassificationType::Keyword => "keyword",
            CitedArtifactClassificationType::CitationSubset => "citation-subset",
            CitedArtifactClassificationType::Chemical => "chemical",
            CitedArtifactClassificationType::PublishingModel => "publishing-model",
            CitedArtifactClassificationType::KnowledgeArtifactType => {
                "knowledge-artifact-type"
            }
            CitedArtifactClassificationType::Coverage => "coverage",
        }
    }
    pub fn system() -> &'static str {
        "http://hl7.org/fhir/cited-artifact-classification-type"
    }
    pub fn version() -> Option<&'static str> {
        Some("5.0.0")
    }
    /// Convert this code into a FHIR `code` primitive (`Code = Element<String, Extension>`).
    ///
    /// Useful for elements like `Patient.gender` that are bound directly to a ValueSet and use
    /// the `code` datatype.
    pub fn to_code(self) -> Code {
        Element {
            id: None,
            extension: None,
            value: Some(self.as_code().to_string()),
        }
    }
    /// Convert this code into a FHIR `Coding` with `system` and (if available) `version` set.
    ///
    /// Useful for `Coding` fields and for inclusion inside `CodeableConcept.coding`.
    pub fn to_coding(self) -> Coding {
        let system: Uri = Element {
            id: None,
            extension: None,
            value: Some(Self::system().to_string()),
        };
        Coding {
            id: None,
            extension: None,
            system: Some(system),
            version: Self::version()
                .map(|v| FhirString {
                    id: None,
                    extension: None,
                    value: Some(v.to_string()),
                }),
            code: Some(self.to_code()),
            display: None,
            user_selected: Option::<Boolean>::None,
        }
    }
    /// Convert this code into a minimal `CodeableConcept` (with a single `coding`).
    ///
    /// This is especially useful for bound elements that use `CodeableConcept` (e.g.
    /// extensible bindings).
    pub fn to_codeable_concept(self) -> CodeableConcept {
        CodeableConcept {
            id: None,
            extension: None,
            coding: Some(vec![self.to_coding()]),
            text: None,
        }
    }
    /// Parse a code string into this enum.
    ///
    /// This is a convenience wrapper around the `TryFrom<&str>` implementation.
    pub fn try_from_code(code: &str) -> Result<Self, ()> {
        <Self as core::convert::TryFrom<&str>>::try_from(code)
    }
    /// Parse from a FHIR `code` primitive (`Code = Element<String, Extension>`).
    pub fn try_from_code_element(code: &Code) -> Result<Self, ()> {
        match code.value.as_deref() {
            Some(v) => Self::try_from_code(v),
            None => Err(()),
        }
    }
}
impl core::convert::TryFrom<&str> for CitedArtifactClassificationType {
    type Error = ();
    fn try_from(s: &str) -> Result<Self, <Self as core::convert::TryFrom<&str>>::Error> {
        match s {
            "publication-type" => Ok(CitedArtifactClassificationType::PublicationType),
            "mesh-heading" => Ok(CitedArtifactClassificationType::MeshHeading),
            "supplemental-mesh-protocol" => {
                Ok(CitedArtifactClassificationType::SupplementalMeshProtocol)
            }
            "supplemental-mesh-disease" => {
                Ok(CitedArtifactClassificationType::SupplementalMeshDisease)
            }
            "supplemental-mesh-organism" => {
                Ok(CitedArtifactClassificationType::SupplementalMeshOrganism)
            }
            "keyword" => Ok(CitedArtifactClassificationType::Keyword),
            "citation-subset" => Ok(CitedArtifactClassificationType::CitationSubset),
            "chemical" => Ok(CitedArtifactClassificationType::Chemical),
            "publishing-model" => Ok(CitedArtifactClassificationType::PublishingModel),
            "knowledge-artifact-type" => {
                Ok(CitedArtifactClassificationType::KnowledgeArtifactType)
            }
            "coverage" => Ok(CitedArtifactClassificationType::Coverage),
            _ => Err(()),
        }
    }
}
impl core::fmt::Display for CitedArtifactClassificationType {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(self.as_code())
    }
}

