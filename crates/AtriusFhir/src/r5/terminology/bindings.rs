// @generated by AtriusValueSetGen
// DO NOT EDIT MANUALLY

/// Trait implemented by generated ValueSet wrappers to provide membership checks
/// for different bound FHIR datatypes (`code`, `Coding`, `CodeableConcept`).
pub trait ValueSetMembership<T> {
    fn contains(v: &T) -> bool;
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum BindingStrength {
    Required,
    Extensible,
    Preferred,
    Example,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum BindingIssue {
    /// Definitive violation (e.g. required binding not satisfied).
    Error { message: &'static str },
    /// Non-fatal issue (e.g. extensible/preferred not satisfied).
    Warning { message: &'static str },
    /// Membership could not be determined (e.g. terminology server unavailable).
    /// This should be surfaced as a warning by validators.
    Unknown { message: &'static str },
}

pub struct Binding<VS> {
    strength: BindingStrength,
    _vs: core::marker::PhantomData<VS>,
}

impl<VS> Binding<VS> {
    pub fn required() -> Self {
        Self {
            strength: BindingStrength::Required,
            _vs: core::marker::PhantomData,
        }
    }

    pub fn extensible() -> Self {
        Self {
            strength: BindingStrength::Extensible,
            _vs: core::marker::PhantomData,
        }
    }

    pub fn preferred() -> Self {
        Self {
            strength: BindingStrength::Preferred,
            _vs: core::marker::PhantomData,
        }
    }

    pub fn example() -> Self {
        Self {
            strength: BindingStrength::Example,
            _vs: core::marker::PhantomData,
        }
    }

    pub fn strength(&self) -> BindingStrength {
        self.strength
    }
}

/// Binding validator for a particular bound datatype `T`.
///
/// This API supports both purely local membership checks and an optional remote
/// terminology fallback.
pub trait BindingValidator<T> {
    /// Local-only check.
    fn check(self, value: &T) -> Result<(), BindingIssue>;

    /// Local-first check with optional remote fallback.
    ///
    /// Semantics (recommended usage):
    /// - First, evaluate local membership via `ValueSetMembership`.
    /// - If local passes -> Ok.
    /// - If local fails and `has_nonlocal_rules == true` (or `is_locally_enumerated == false`),
    ///   then attempt remote `$validate-code` using `remote_validate`.
    /// - If remote returns `Some(true)` -> Ok.
    /// - If remote returns `Some(false)` -> treat as a definitive failure.
    /// - If remote returns `None` -> Unknown (do not emit Error).
    ///
    /// `remote_validate` must implement ValueSet `$validate-code` semantics:
    /// `remote_validate(valueset_url, system, code) -> Option<bool>`.
    fn check_with_remote(
        self,
        value: &T,
        valueset_url: &str,
        has_nonlocal_rules: bool,
        is_locally_enumerated: bool,
        system_and_code: Option<(&str, &str)>,
        remote_validate: Option<&dyn Fn(&str, &str, &str) -> Option<bool>>,
    ) -> Result<(), BindingIssue>;
}

impl<VS, T> BindingValidator<T> for Binding<VS>
where
    VS: ValueSetMembership<T>,
{
    fn check(self, value: &T) -> Result<(), BindingIssue> {
        let ok = VS::contains(value);
        match self.strength {
            BindingStrength::Required => {
                if ok {
                    Ok(())
                } else {
                    Err(BindingIssue::Error {
                        message: "Required binding violated",
                    })
                }
            }
            BindingStrength::Extensible => {
                if ok {
                    Ok(())
                } else {
                    Err(BindingIssue::Warning {
                        message: "Extensible binding not satisfied",
                    })
                }
            }
            BindingStrength::Preferred => {
                if ok {
                    Ok(())
                } else {
                    Err(BindingIssue::Warning {
                        message: "Preferred binding not satisfied",
                    })
                }
            }
            BindingStrength::Example => Ok(()),
        }
    }

    fn check_with_remote(
        self,
        value: &T,
        valueset_url: &str,
        has_nonlocal_rules: bool,
        is_locally_enumerated: bool,
        system_and_code: Option<(&str, &str)>,
        remote_validate: Option<&dyn Fn(&str, &str, &str) -> Option<bool>>,
    ) -> Result<(), BindingIssue> {
        // 1) Local first
        if VS::contains(value) {
            return Ok(());
        }

        // Example bindings are never enforced.
        if matches!(self.strength, BindingStrength::Example) {
            return Ok(());
        }

        // 2) Decide whether remote fallback is appropriate.
        // If the ValueSet is fully locally enumerable, a local failure is definitive.
        let should_try_remote = has_nonlocal_rules || !is_locally_enumerated;

        if should_try_remote {
            if let (Some((system, code)), Some(remote)) = (system_and_code, remote_validate) {
                match remote(valueset_url, system, code) {
                    Some(true) => return Ok(()),
                    Some(false) => {
                        // definitive remote failure -> fall through to strength mapping
                    }
                    None => {
                        // unknown (e.g. unreachable) -> never error
                        return Err(BindingIssue::Unknown {
                            message: "ValueSet membership could not be determined (terminology unavailable)",
                        });
                    }
                }
            } else {
                // We wanted remote but cannot call it due to missing (system,code) or client.
                return Err(BindingIssue::Unknown {
                    message: "ValueSet requires terminology validation but inputs/client were unavailable",
                });
            }
        }

        // 3) Final mapping by strength
        match self.strength {
            BindingStrength::Required => Err(BindingIssue::Error {
                message: "Required binding violated",
            }),
            BindingStrength::Extensible => Err(BindingIssue::Warning {
                message: "Extensible binding not satisfied",
            }),
            BindingStrength::Preferred => Err(BindingIssue::Warning {
                message: "Preferred binding not satisfied",
            }),
            BindingStrength::Example => Ok(()),
        }
    }
}
